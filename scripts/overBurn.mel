// #################################################################################################
// #    OverBurn 1.6 	[ created by: Peter Shipkov ] [ email: pshipkov@yahoo.com ]		   #
// #			[ modified by: Mike Harris ]  [ email: mikeh@dezfx.com ]		   #
// #################################################################################################

// Our friend Mike Harris spent couple of hours to organize the stuff nicely.
// He improved the naming conventions for all the ramps, arrayMappers, whatsoever other for easy scene navigation.
// He cleaned-up and organized the code for easy reading/editing.
// Thanks mate.

// $buffer[0] - emitter
// $buffer[1] - trailsParticle
// $buffer[2] - trailsParticleShape
// $buffer[3] - arrayMapper ( radiusMultPP )
// $buffer[4] - ramp ( radiusMultPP )
// $buffer[5] - arrayMapper ( radiusRandPP )
// $buffer[6] - ramp ( radiusRandPP )
// $buffer[7] - arrayMapper ( opacityPP ) -> transparency
// $buffer[8] - ramp ( opacityPP )
// $buffer[9] - leadParticle
// $buffer[10] - emitter ( leadParticleShape )
// $buffer[11] - leadParticleShape
// $buffer[12] - fluidShape
// $buffer[13] - particleSamplerInfo
// $buffer[14] - arrayMapper ( userScalar1PP ) -> textureOrigin
// $buffer[15] - ramp ( userScalar1PP )
// $buffer[16] - arrayMapper ( userScalar2PP ) -> textureScale
// $buffer[17] - ramp ( userScalar2PP )
// $buffer[18] - arrayMapper ( userScalar3PP ) -> incandescence bias
// $buffer[19] - ramp ( userScalar3PP )
// $buffer[20] - arrayMapper ( userScalar4PP ) -> textureTime
// $buffer[21] - ramp ( userScalar4PP )
// $buffer[22] - arrayMapper ( userScalar5PP ) -> amplitude
// $buffer[23] - ramp ( userScalar5PP )
// $buffer[24] - arrayMapper ( userVector1PP ) -> colorInputBias
// $buffer[25] - ramp ( userVector1PP )
// $buffer[26] - arrayMapper ( userVector2PP ) -> opacityInputBias
// $buffer[27] - ramp ( userVector2PP )
// $buffer[28] - arrayMapper ( radiusMinPP )
// $buffer[29] - ramp ( radiusMinPP )
// $buffer[30] - arrayMapper ( radiusMaxPP )
// $buffer[31] - ramp ( radiusMaxPP )
// $buffer[32] - arrayMapper ( frequencyPP )
// $buffer[33] - ramp ( frequencyPP )

source "doSetFluidState.mel";

// #################################################################################################
// #    CREATE UI ( MAIN WINDOW )								   #
// #################################################################################################

global proc createMainWindow_OVERBURN_PPLE ()
{
	if (`window -ex mainWindow_OVERBURN_PPLE`)
	{
		deleteUI mainWindow_OVERBURN_PPLE;
	}

	string $os = `about -os`;

	window -t "OverBurn 1.6" mainWindow_OVERBURN_PPLE;
		columnLayout;

			if ( $os == "mac" )
			{
				frameLayout -w 380 -h 130 -l " Create" -bs "etchedIn" -mh 2 -mw 2;
			}
			else
			{
				frameLayout -l " Create" -bs "etchedIn" -mh 2 -mw 2;
			}
				columnLayout;
					rowColumnLayout -nc 2 -cw 1 225 -cw 2 145 -co 1 "left" 55;
						radioCollection effectType;
							radioButton -sl -l "Explosion" -al "left" explosion;
							radioButton -l "Fire Balls" -al "left" fireBalls;
							radioButton -l "Tendrils [ Big ]" -al "left" tendBig;
							radioButton -l "Tendrils [ Small ]" -al "left" tendSmall;
							radioButton -l "Smoke" -al "left" smoke;
							radioButton -l "Fire" -al "left" fire;
							radioButton -l "Ice" -al "left" ice;
					setParent ..;

					rowColumnLayout -nc 2 -cw 1 185 -cw 2 185;
						button -l "OK" -c "createEffect_OVERBURN_PPLE ( `radioCollection -q -sl effectType` )";
						button -l "Info" -c createInfoWindow_OVERBURN_PPLE;
					setParent ..;
				setParent ..;
			setParent ..;

			if ( $os == "mac" )
			{
				frameLayout -w 380 -h 373 -l " VoxelEditor" -bs "etchedIn" -mh 2 -mw 2;
			}
			else
			{
				frameLayout -l " VoxelEditor" -bs "etchedIn" -mh 2 -mw 2;
			}
				columnLayout;
					rowColumnLayout -nc 3 -cw 1 100 -cw 2 240 -cw 3 30;
						text -l "Fluid Container   " -al "right";
						textField -ed 0 fluidContainer_textField_OVERBURN_PPLE;
						button -l "<<" -c createVoxelHandles_OVERBURN_PPLE;
						text -l "3D Texture   " -al "right";
						textField -ed 0 texture_textField_OVERBURN_PPLE;
						button -l "<<" -c getTexture_OVERBURN_PPLE;
					setParent ..;

					text -l "" -h 10;

					rowColumnLayout -nc 2 -cw 1 101 -cw 2 200;
						text -l "";
						checkBox -l "Interactive Update" -al "left" -v 1 interactiveUpdate_checkBox_OVERBURN_PPLE;
					setParent ..;

					radioButtonGrp -l "Blend Mode" -nrb 3 -la3 "Replace" "Add" "Remove" -sl 1 -cw 1 100 -cw 2 85 -cw 3 85 -cw 4 85 blend_radioButtonGrp_OVERBURN_PPLE;
					text -l "" -h 10;

					rowColumnLayout -nc 4 -cw 1 310 -cw 2 20 -cw 3 20 -cw 4 20;
						floatSliderGrp -l "Density" -min 0 -max 1 -f 1 -cc "interactiveUpdate_OVERBURN_PPLE ( 1 )" -cw 1 100 -cw 2 50 density_floatSliderGrp_OVERBURN_PPLE;
						button -l "G" -c "updateUI_OVERBURN_PPLE ( 1 )";
						button -l "S" -c "setData_OVERBURN_PPLE ( 1, 0 )";
						button -l "T" -c "setData_OVERBURN_PPLE ( 1, 1 )";
					setParent ..;

					text -l "" -h 4;

					rowColumnLayout -nc 6 -cw 1 100 -cw 2 50 -cw 3 160 -cw 4 20 -cw 5 20 -cw 6 20;
						text -l "Velocity X   " -al "right";
						floatField -cc "interactiveUpdate_OVERBURN_PPLE ( 21 )" velocityX_floatField_OVERBURN_PPLE;
						text -l "";
						button -l "G" -c "updateUI_OVERBURN_PPLE ( 21 )";
						button -l "S" -c "setData_OVERBURN_PPLE ( 21, 0 )";
						button -l "T" -c "setData_OVERBURN_PPLE ( 21, 1 )";
						text -l "Velocity Y   " -al "right";
						floatField -cc "interactiveUpdate_OVERBURN_PPLE ( 22 )" velocityY_floatField_OVERBURN_PPLE;
						text -l "";
						button -l "G" -c "updateUI_OVERBURN_PPLE ( 22 )";
						button -l "S" -c "setData_OVERBURN_PPLE ( 22, 0 )";
						button -l "T" -c "setData_OVERBURN_PPLE ( 22, 1 )";
						text -l "Velocity Z   " -al "right";
						floatField -cc "interactiveUpdate_OVERBURN_PPLE ( 23 )" velocityZ_floatField_OVERBURN_PPLE;
						text -l "";
						button -l "G" -c "updateUI_OVERBURN_PPLE ( 23 )";
						button -l "S" -c "setData_OVERBURN_PPLE ( 23, 0 )";
						button -l "T" -c "setData_OVERBURN_PPLE ( 23, 1 )";
					setParent ..;

					text -l "" -h 4;

					rowColumnLayout -nc 4 -cw 1 310 -cw 2 20 -cw 3 20 -cw 4 20;
						floatSliderGrp -l "Temperature" -min 0 -max 1 -f 1 -cc "interactiveUpdate_OVERBURN_PPLE ( 3 )" -cw 1 100 -cw 2 50 temperature_floatSliderGrp_OVERBURN_PPLE;
						button -l "G" -c "updateUI_OVERBURN_PPLE ( 3 )";
						button -l "S" -c "setData_OVERBURN_PPLE ( 3, 0 )";
						button -l "T" -c "setData_OVERBURN_PPLE ( 3, 1 )";
						floatSliderGrp -l "Fuel" -min 0 -max 1 -f 1 -cc "interactiveUpdate_OVERBURN_PPLE ( 4 )" -cw 1 100 -cw 2 50 fuel_floatSliderGrp_OVERBURN_PPLE;
						button -l "G" -c "updateUI_OVERBURN_PPLE ( 4 )";
						button -l "S" -c "setData_OVERBURN_PPLE ( 4, 0 )";
						button -l "T" -c "setData_OVERBURN_PPLE ( 4, 1 )";
						colorSliderGrp -label "Color" -rgb 0 0 0 -cc "interactiveUpdate_OVERBURN_PPLE ( 5 )" -cw 1 103 -cw 2 47 -cw 3 160 color_colorSliderGrp_OVERBURN_PPLE;
						button -l "G" -c "updateUI_OVERBURN_PPLE ( 5 )";
						button -l "S" -c "setData_OVERBURN_PPLE ( 5, 0 )";
						button -l "T" -c "setData_OVERBURN_PPLE ( 5, 1 )";
						floatSliderGrp -l "Falloff" -min 0 -max 1 -f 1 -cc "interactiveUpdate_OVERBURN_PPLE ( 6 )" -cw 1 100 -cw 2 50 falloff_floatSliderGrp_OVERBURN_PPLE;
						button -l "G" -c "updateUI_OVERBURN_PPLE ( 6 )";
						button -l "S" -c "setData_OVERBURN_PPLE ( 6, 0 )";
						button -l "T" -c "setData_OVERBURN_PPLE ( 6, 1 )";
					setParent ..;
				setParent ..;
			setParent ..;
		setParent ..;

	showWindow mainWindow_OVERBURN_PPLE;

	if ( $os == "nt" )
	{
		window -e -wh 387 437 mainWindow_OVERBURN_PPLE;
	}
	else if ( $os == "linux" )
	{
		window -e -wh 377 480 mainWindow_OVERBURN_PPLE;
	}
	else if ( $os == "mac" )
	{
		window -e -wh 395 540 mainWindow_OVERBURN_PPLE;
	}
}

createMainWindow_OVERBURN_PPLE;

// #################################################################################################
// #    CREATE UI ( INFO WINDOW )								   #
// #################################################################################################

global proc createInfoWindow_OVERBURN_PPLE ()
{
	if (`window -ex infoWindow_OVERBURN_PPLE`)
	{
		deleteUI infoWindow_OVERBURN_PPLE;
	}

	string $os = `about -os`;

	window -t "Attributes Relationship Table" infoWindow_OVERBURN_PPLE;
		columnLayout;
			string $info = "particleShape   |  fluidShape\n";
			$info += "----------------+----------------------\n";
			$info += "opacityPP       |  transparency\n";
			$info += "userVector1PPX  |  colorInputBias\n";
			$info += "userVector1PPY  |  incandescenceInputBias\n";
			$info += "userVector1PPZ  |  opacityInputBias\n";
			$info += "userVector2PPX  |  amplitude\n";
			$info += "userVector2PPY  |  textureTime\n";
			$info += "userVector2PPZ  |  textureScale\n";
			$info += "userVector3PPX  |  textureOrigin\n";
			$info += "\n";
			$info += "Additional control attributes are located inside\n";
			$info += "the particleShape's \"Extra Attributes\" folder.\n";
			$info += "\n";
			$info += "===========================================\n";
			$info += "For bugs and problems -> pshipkov@yahoo.com";

			if ( $os == "mac" )
			{
				scrollField -w 379 -h 270 -ed 0 -tx $info;
			}
			else
			{
				scrollField -w 379 -h 245 -ed 0 -tx $info;
			}

		setParent ..;
	showWindow infoWindow_OVERBURN_PPLE;

	if ( $os == "nt" )
	{
		window -e -wh 387 269 infoWindow_OVERBURN_PPLE;
	}
	else if ( $os == "linux" )
	{
		window -e -wh 378 244 infoWindow_OVERBURN_PPLE;
	}
	else if ( $os == "mac" )
	{
		window -e -wh 377 275 infoWindow_OVERBURN_PPLE;
	}
}

// #################################################################################################
// #    CREATE EXPLOSION									   #
// #################################################################################################

global proc createEffect_OVERBURN_PPLE ( string $effectType )
{
	cycleCheck -e off;

	switch ( $effectType )
	{
		case "explosion":
			string $buffer[], $temp[], $explression;

			// create emitter

			$temp = `emitter -pos 0 0 0 -type omni -r 100 -sro 0 -nuv 0 -cye none -cyi 1 -spd 1 -srn 0 -nsp 1 -tsp 0 -mxd 0 -mnd 0 -dx 1 -dy 0 -dz 0 -sp 0`;
			$buffer[0] = $temp[0];

			// set emission attributes

			setAttr ( $buffer[0] + ".scale" ) 0.5 0.5 0.5;
			currentTime 1;
			setKeyframe -v 120 ( $buffer[0] + ".rate" );
			currentTime 40;
			setKeyframe -v 0 ( $buffer[0] + ".rate" );
			currentTime 1;
			setAttr ( $buffer[0] + ".speedRandom" ) 0.5;
			setAttr ( $buffer[0] + ".awayFromCenter" ) 2;
			setAttr ( $buffer[0] + ".randomDirection" ) 1;
			setAttr ( $buffer[0] + ".directionalSpeed" ) 1;
			setAttr ( $buffer[0] + ".emitterType" ) 4;
			setAttr ( $buffer[0] + ".volumeShape" ) 1;
			setAttr ( $buffer[0] + ".directionX" ) 0;

			// create trailsParticleShape

			$temp = `particle`;
			$buffer[1] = $temp[0];
			$buffer[2] = $temp[1];

			// connect trailsParticleShape to emitter

			connectDynamic -em $buffer[0] $buffer[2];

			// manage trailsParticleShape attributes

			setAttr ( $buffer[2] + ".conserve" ) 0.955;
			setAttr ( $buffer[2] + ".lifespanMode" ) 2;
			setAttr ( $buffer[2] + ".lifespan" ) 10;
			setAttr ( $buffer[2] + ".lifespanRandom" ) 1;
			setAttr ( $buffer[2] + ".particleRenderType" ) 8;
			addAttr -is true -ln "betterIllumination" -at bool -dv false $buffer[2];
			addAttr -is true -ln "surfaceShading" -at "float" -smn 0 -smx 1 -dv 0 $buffer[2];
			addAttr -is true -ln "threshold" -at "float" -smn 0 -smx 10 -dv 0 $buffer[2];
			addAttr -is true -ln "radius" -at "float" -smn 0 -smx 20 -dv 2 $buffer[2];
			addAttr -ln radiusPP -dt doubleArray $buffer[2];
			addAttr -ln radiusMultPP -dt doubleArray $buffer[2];
			addAttr -ln radiusStartPP -dt doubleArray $buffer[2];
			addAttr -ln radiusMinPP -dt doubleArray $buffer[2];
			addAttr -ln radiusMaxPP -dt doubleArray $buffer[2];
			addAttr -ln opacityPP -dt doubleArray $buffer[2];
			addAttr -ln colorInputBiasPP -dt doubleArray $buffer[2];
			addAttr -ln incandescenceInputBiasPP -dt doubleArray $buffer[2];
			addAttr -ln opacityInputBiasPP -dt doubleArray $buffer[2];
			addAttr -ln amplitudePP -dt doubleArray $buffer[2];
			addAttr -ln textureTimePP -dt doubleArray $buffer[2];
			addAttr -ln textureScalePP -dt doubleArray $buffer[2];
			addAttr -ln textureOriginPP -dt doubleArray $buffer[2];
			addAttr -ln userVector1PP -dt vectorArray $buffer[2];
			addAttr -ln userVector2PP -dt vectorArray $buffer[2];
			addAttr -ln userVector3PP -dt vectorArray $buffer[2];
			addAttr -ln velocityRand -at double -smn 0 -smx 2 -dv 0.05 $buffer[2];
			addAttr -ln radiusMult -at double -smn 0 -smx 20 -dv 25 $buffer[2];
			addAttr -ln radiusMin -at double -smn 0 -smx 20 -dv 0.75 $buffer[2];
			addAttr -ln radiusMax -at double -smn 0 -smx 20 -dv 1.5 $buffer[2];
			addAttr -ln colorInputBiasMin -at double -smn -1 -smx 1 -dv 0 $buffer[2];
			addAttr -ln colorInputBiasMax -at double -smn -1 -smx 1 -dv 0 $buffer[2];
			addAttr -ln incandescenceInputBiasMin -at double -smn -1 -smx 1 -dv -1 $buffer[2];
			addAttr -ln incandescenceInputBiasMax -at double -smn -1 -smx 1 -dv 1 $buffer[2];
			addAttr -ln opacityInputBiasMin -at double -smn -1 -smx 1 -dv 0 $buffer[2];
			addAttr -ln opacityInputBiasMax -at double -smn -1 -smx 1 -dv 1 $buffer[2];
			addAttr -ln amplitudeMin -at double -smn 0 -smx 1 -dv 0.4 $buffer[2];
			addAttr -ln amplitudeMax -at double -smn 0 -smx 3 -dv 2.5 $buffer[2];
			addAttr -ln textureTimeMin -at double -smn 0 -smx 1 -dv 0 $buffer[2];
			addAttr -ln textureTimeMax -at double -smn 0 -smx 1 -dv 1 $buffer[2];
			addAttr -ln textureScaleMin -at double -smn 0 -smx 10 -dv 0.4 $buffer[2];
			addAttr -ln textureScaleMax -at double -smn 0 -smx 10 -dv 1 $buffer[2];
			addAttr -ln textureOriginMin -at double -smn 0 -smx 2 -dv 0 $buffer[2];
			addAttr -ln textureOriginMax -at double -smn 0 -smx 2 -dv 1 $buffer[2];

			// create fluidShape

			$buffer[12] = `create3DFluid 20 20 20 10 10 10`;

			// MAYA 5.0 COMPATIBILITY ( THE NEXT TWO LINES ARE NOT NEEDED FOR MAYA 6+ )
			//
			$temp = `ls -sl`;
			$buffer[12] = $temp[0];

			// manage fluidShape attributes

			setAttr ( $buffer[12] + ".densityMethod" ) 3;
			setAttr ( $buffer[12] + ".densityGradient" ) 11;
			setAttr ( $buffer[12] + ".velocityMethod" ) 0;
			setAttr ( $buffer[12] + ".boundaryDraw" ) 4;
			setAttr ( $buffer[12] + ".wireframeDisplay" ) 0;
			setAttr ( $buffer[12] + ".dropoffShape" ) 1;
			setAttr ( $buffer[12] + ".edgeDropoff" ) 0.35;
			setAttr ( $buffer[12] + ".quality" ) 1;
			setAttr ( $buffer[12] + ".renderInterpolator" ) 3;
			setAttr ( $buffer[12] + ".colorTexture" ) 1;
			setAttr ( $buffer[12] + ".incandTexture" ) 1;
			setAttr ( $buffer[12] + ".opacityTexture" ) 1;
			setAttr ( $buffer[12] + ".textureType" ) 4;
			setAttr ( $buffer[12] + ".colorTexGain" ) 0.175;
			setAttr ( $buffer[12] + ".incandTexGain" ) 1.049;
			setAttr ( $buffer[12] + ".opacityTexGain" ) 0.547;
			setAttr ( $buffer[12] + ".color[0].color_Color" ) 0 0 0;
			setAttr ( $buffer[12] + ".colorInput" ) 4;
			setAttr ( $buffer[12] + ".incandescence[0].incandescence_Position" ) 0.2;
			setAttr ( $buffer[12] + ".incandescence[0].incandescence_Color" ) 0.15 0.15 0.15;
			setAttr ( $buffer[12] + ".incandescence[1].incandescence_Position" ) 0.408;
			setAttr ( $buffer[12] + ".incandescence[1].incandescence_Color" ) 0.425 0.056145 0.0221;
			setAttr ( $buffer[12] + ".incandescence[1].incandescence_Interp" ) 3;
			setAttr ( $buffer[12] + ".incandescence[2].incandescence_Position" ) 0.5;
			setAttr ( $buffer[12] + ".incandescence[2].incandescence_Color" ) 0.784 0.1279 0.046256;
			setAttr ( $buffer[12] + ".incandescence[2].incandescence_Interp" ) 2;
			setAttr ( $buffer[12] + ".incandescence[3].incandescence_Position" ) 0.586;
			setAttr ( $buffer[12] + ".incandescence[3].incandescence_Color" ) 1.747 0.361157 0.092591;
			setAttr ( $buffer[12] + ".incandescence[3].incandescence_Interp" ) 3;
			setAttr ( $buffer[12] + ".incandescence[4].incandescence_Color" ) 4 1.012111 0.276;
			setAttr ( $buffer[12] + ".incandescence[4].incandescence_Position" ) 0.657;
			setAttr ( $buffer[12] + ".incandescence[4].incandescence_Interp" ) 2;
			setAttr ( $buffer[12] + ".incandescenceInput" ) 4;
			setAttr ( $buffer[12] + ".opacity[0].opacity_Position" ) 0.164;
			setAttr ( $buffer[12] + ".opacity[1].opacity_FloatValue" ) 0.003;
			setAttr ( $buffer[12] + ".opacity[1].opacity_Position" ) 0.293;
			setAttr ( $buffer[12] + ".opacity[1].opacity_Interp" ) 1;
			setAttr ( $buffer[12] + ".opacity[2].opacity_FloatValue" ) 0.48;
			setAttr ( $buffer[12] + ".opacity[2].opacity_Position" ) 0.329;
			setAttr ( $buffer[12] + ".opacity[2].opacity_Interp" ) 1;
			setAttr ( $buffer[12] + ".opacity[3].opacity_FloatValue" ) 0.8;
			setAttr ( $buffer[12] + ".opacity[3].opacity_Position" ) 0.429;
			setAttr ( $buffer[12] + ".opacity[3].opacity_Interp" ) 1;
			setAttr ( $buffer[12] + ".opacity[4].opacity_FloatValue" ) 0.96;
			setAttr ( $buffer[12] + ".opacity[4].opacity_Position" ) 0.75;
			setAttr ( $buffer[12] + ".opacity[4].opacity_Interp" ) 1;
			setAttr ( $buffer[12] + ".ratio" ) 0.524;
			setAttr ( $buffer[12] + ".frequencyRatio" ) 1.961;
			setAttr ( $buffer[12] + ".depthMax" ) 4;
			setAttr ( $buffer[12] + ".inflection" ) 1;
			setAttr ( $buffer[12] + ".frequency" ) 2.184;
			setAttr ( $buffer[12] + ".textureScaleX" ) 5.5;
			setAttr ( $buffer[12] + ".textureScaleY" ) 5.5;
			setAttr ( $buffer[12] + ".textureScaleZ" ) 5.5;
			setAttr ( $buffer[12] + ".realLights" ) 0;
			setAttr ( $buffer[12] + ".castsShadows" ) 0;
			setAttr ( $buffer[12] + ".receiveShadows" ) 0;
			setAttr ( $buffer[12] + ".primaryVisibility" ) 0;
			setAttr ( $buffer[12] + ".visibleInReflections" ) 0;
			setAttr ( $buffer[12] + ".visibleInRefractions" ) 0;

			// assign fluidShape to trailsParticleShape

			$temp = `listConnections -s 0 -d 1 ( $buffer[12] + ".outColor" )`;
			select $buffer[2];
			sets -e -forceElement $temp[0];

			// create particleSamplerInfo

			$buffer[13] = `shadingNode -asUtility particleSamplerInfo`;

			// create arrayMapper for radiusMultPP

			$temp = `arrayMapper -target $buffer[2] -destAttr radiusMultPP -inputV ageNormalized -type ramp`;
			$buffer[3] = $temp[0];

			// create ramp for radiusMultPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[3] + ".computeNodeColor" )`;
			$buffer[4] = $temp[0];

			setAttr ( $buffer[4] + ".colorEntryList[0].color" ) 0.5 0.5 0.5;
			removeMultiInstance -break true ( $buffer[4] + ".colorEntryList[1]" );
			setAttr ( $buffer[4] + ".colorEntryList[2].color" ) 1 1 1;
			setAttr ( $buffer[4] + ".colorEntryList[2].position" ) 1;

			// create arrayMapper for radiusStartPP

			$temp = `arrayMapper -target $buffer[2] -destAttr radiusStartPP -inputV ageNormalized -type ramp`;
			$buffer[5] = $temp[0];

			// create ramp for radiusStartPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[5] + ".computeNodeColor" )`;
			$buffer[6] = $temp[0];

			setAttr ( $buffer[6] + ".colorEntryList[0].color" ) 0.9 0.9 0.9;
			removeMultiInstance -break true ( $buffer[6] + ".colorEntryList[1]" );
			setAttr ( $buffer[6] + ".colorEntryList[2].color" ) 1 1 1;
			setAttr ( $buffer[6] + ".colorEntryList[2].position" ) 1;
			setAttr ( $buffer[6] + ".noise" ) 1;

			// create arrayMapper for radiusMinPP

			$temp = `arrayMapper -target $buffer[2] -destAttr radiusMinPP -inputV birthTime -type ramp`;
			$buffer[28] = $temp[0];

			// create ramp for radiusMinPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[28] + ".computeNodeColor" )`;
			$buffer[29] = $temp[0];

			setAttr ( $buffer[29] + ".colorEntryList[0].color" ) 1 1 1;
			removeMultiInstance -break true ( $buffer[29] + ".colorEntryList[1]" );
			removeMultiInstance -break true ( $buffer[29] + ".colorEntryList[2]" );
			setAttr ( $buffer[29] + ".noise" ) 1;

			// create arrayMapper for radiusMaxPP

			$temp = `arrayMapper -target $buffer[2] -destAttr radiusMaxPP -inputV birthTime -type ramp`;
			$buffer[30] = $temp[0];

			// create ramp for radiusMaxPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[30] + ".computeNodeColor" )`;
			$buffer[31] = $temp[0];

			setAttr ( $buffer[31] + ".colorEntryList[0].color" ) 1 1 1;
			removeMultiInstance -break true ( $buffer[31] + ".colorEntryList[1]" );
			removeMultiInstance -break true ( $buffer[31] + ".colorEntryList[2]" );
			setAttr ( $buffer[31] + ".noise" ) 1;

			// create arrayMapper for opacityPP

			$temp = `arrayMapper -target $buffer[2] -destAttr opacityPP -inputV ageNormalized -type ramp`;
			$buffer[7] = $temp[0];

			// create ramp for opacityPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[7] + ".computeNodeColor" )`;
			$buffer[8] = $temp[0];

			setAttr ( $buffer[8] + ".colorEntryList[0].color" ) 0.001 0.001 0.001;
			removeMultiInstance -break true ( $buffer[8] + ".colorEntryList[1]" );
			removeMultiInstance -break true ( $buffer[8] + ".colorEntryList[2]" );

			// create connections between particleSamplerInfo and opacityPP

			connectAttr -f ( $buffer[13] + ".opacityPP" ) ( $buffer[12] + ".transparencyR" );
			connectAttr -f ( $buffer[13] + ".opacityPP" ) ( $buffer[12] + ".transparencyG" );
			connectAttr -f ( $buffer[13] + ".opacityPP" ) ( $buffer[12] + ".transparencyB" );

			// create arrayMapper for textureOriginPP

			$temp = `arrayMapper -target $buffer[2] -destAttr textureOriginPP -inputV ageNormalized -type ramp`;
			$buffer[14] = $temp[0];

			connectAttr -f ( $buffer[2] + ".textureOriginMin" ) ( $buffer[14] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".textureOriginMax" ) ( $buffer[14] + ".maxValue" );

			// create ramp for textureOriginPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[14] + ".computeNodeColor" )`;
			$buffer[15] = $temp[0];

			setAttr ( $buffer[15] + ".colorEntryList[0].color" ) 1 1 1;
			removeMultiInstance -break true ( $buffer[15] + ".colorEntryList[1]" );
			setAttr ( $buffer[15] + ".colorEntryList[2].color" ) 0 0 0;
			setAttr ( $buffer[15] + ".colorEntryList[2].position" ) 1;
			setAttr ( $buffer[15] + ".noise" ) 1;

			// create connections between particleSamplerInfo and textureOriginPP

			connectAttr -f ( $buffer[13] + ".userVector3PPX" ) ( $buffer[12] + ".textureOriginX" );
			connectAttr -f ( $buffer[13] + ".userVector3PPX" ) ( $buffer[12] + ".textureOriginY" );
			connectAttr -f ( $buffer[13] + ".userVector3PPX" ) ( $buffer[12] + ".textureOriginZ" );

			// create arrayMapper for textureScalePP

			$temp = `arrayMapper -target $buffer[2] -destAttr textureScalePP -inputV ageNormalized -type ramp`;
			$buffer[16] = $temp[0];

			connectAttr -f ( $buffer[2] + ".textureScaleMin" ) ( $buffer[16] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".textureScaleMax" ) ( $buffer[16] + ".maxValue" );

			// create ramp for textureScalePP

			$temp = `listConnections -s 1 -d 0 ( $buffer[16] + ".computeNodeColor" )`;
			$buffer[17] = $temp[0];

			setAttr ( $buffer[17] + ".colorEntryList[0].color" ) 1 1 1;
			removeMultiInstance -break true ( $buffer[17] + ".colorEntryList[1]" );
			setAttr ( $buffer[17] + ".colorEntryList[2].color" ) 0.5 0.5 0.5;
			setAttr ( $buffer[17] + ".colorEntryList[2].position" ) 1;

			// create connections between particleSamplerInfo and textureScalePP

			connectAttr -f ( $buffer[13] + ".userVector2PPZ" ) ( $buffer[12] + ".textureScaleX" );
			connectAttr -f ( $buffer[13] + ".userVector2PPZ" ) ( $buffer[12] + ".textureScaleY" );
			connectAttr -f ( $buffer[13] + ".userVector2PPZ" ) ( $buffer[12] + ".textureScaleZ" );

			// create arrayMapper for incandescenceInputBiasPP

			$temp = `arrayMapper -target $buffer[2] -destAttr incandescenceInputBiasPP -inputV ageNormalized -type ramp`;
			$buffer[18] = $temp[0];

			connectAttr -f ( $buffer[2] + ".incandescenceInputBiasMin" ) ( $buffer[18] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".incandescenceInputBiasMax" ) ( $buffer[18] + ".maxValue" );

			// create ramp for incandescenceInputBiasPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[18] + ".computeNodeColor" )`;
			$buffer[19] = $temp[0];

			setAttr ( $buffer[19] + ".interpolation" ) 1;
			setAttr ( $buffer[19] + ".colorEntryList[0].color" ) 0.85 0.85 0.85;
			setAttr ( $buffer[19] + ".colorEntryList[1].color" ) 0.35 0.35 0.35;
			setAttr ( $buffer[19] + ".colorEntryList[1].position" ) 0.35;
			setAttr ( $buffer[19] + ".colorEntryList[2].color" ) 0 0 0;
			setAttr ( $buffer[19] + ".colorEntryList[2].position" ) 1;

			// create connections between particleSamplerInfo and incandescenceInputBiasPP

			connectAttr -f ( $buffer[13] + ".userVector1PPY" ) ( $buffer[12] + ".incandescenceInputBias" );

			// create arrayMapper for textureTimePP

			$temp = `arrayMapper -target $buffer[2] -destAttr textureTimePP -inputV ageNormalized -type ramp`;
			$buffer[20] = $temp[0];

			connectAttr -f ( $buffer[2] + ".textureTimeMin" ) ( $buffer[20] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".textureTimeMax" ) ( $buffer[20] + ".maxValue" );

			// create ramp for textureTimePP

			$temp = `listConnections -s 1 -d 0 ( $buffer[20] + ".computeNodeColor" )`;
			$buffer[21] = $temp[0];

			setAttr ( $buffer[21] + ".interpolation" ) 3;
			setAttr ( $buffer[21] + ".colorEntryList[0].color" ) 0 0 0;
			removeMultiInstance -break true ( $buffer[21] + ".colorEntryList[1]" );
			setAttr ( $buffer[21] + ".colorEntryList[2].color" ) 0.75 0.75 0.75;
			setAttr ( $buffer[21] + ".colorEntryList[2].position" ) 1;

			// create connections between particleSamplerInfo and textureTimePP

			connectAttr -f ( $buffer[13] + ".userVector2PPY" ) ( $buffer[12] + ".textureTime" );

			// create arrayMapper for amplitudePP

			$temp = `arrayMapper -target $buffer[2] -destAttr amplitudePP -inputV ageNormalized -type ramp`;
			$buffer[22] = $temp[0];

			connectAttr -f ( $buffer[2] + ".amplitudeMin" ) ( $buffer[22] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".amplitudeMax" ) ( $buffer[22] + ".maxValue" );

			// create ramp for amplitudePP

			$temp = `listConnections -s 1 -d 0 ( $buffer[22] + ".computeNodeColor" )`;
			$buffer[23] = $temp[0];

			setAttr ( $buffer[23] + ".colorEntryList[0].color" ) 0 0 0;
			removeMultiInstance -break true ( $buffer[23] + ".colorEntryList[1]" );
			setAttr ( $buffer[23] + ".colorEntryList[2].color" ) 1 1 1;
			setAttr ( $buffer[23] + ".colorEntryList[2].position" ) 1;

			// create connections between particleSamplerInfo and amplitudePP

			connectAttr -f ( $buffer[13] + ".userVector2PPX" ) ( $buffer[12] + ".amplitude" );

			// create arrayMapper for colorInputBiasPP

			$temp = `arrayMapper -target $buffer[2] -destAttr colorInputBiasPP -inputV ageNormalized -type ramp`;
			$buffer[24] = $temp[0];

			connectAttr -f ( $buffer[2] + ".colorInputBiasMin" ) ( $buffer[24] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".colorInputBiasMax" ) ( $buffer[24] + ".maxValue" );

			// create ramp for colorInputBiasPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[24] + ".computeNodeColor" )`;
			$buffer[25] = $temp[0];

			setAttr ( $buffer[25] + ".colorEntryList[0].color" ) 0 0 0;
			removeMultiInstance -break true ( $buffer[25] + ".colorEntryList[1]" );
			removeMultiInstance -break true ( $buffer[25] + ".colorEntryList[2]" );

			// create connections between particleSamplerInfo and colorInputBiasPP

			connectAttr -f ( $buffer[13] + ".userVector1PPX" ) ( $buffer[12] + ".colorInputBias" );

			// create arrayMapper for opacityInputBiasPP

			$temp = `arrayMapper -target $buffer[2] -destAttr opacityInputBiasPP -inputV ageNormalized -type ramp`;
			$buffer[26] = $temp[0];

			connectAttr -f ( $buffer[2] + ".opacityInputBiasMin" ) ( $buffer[26] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".opacityInputBiasMax" ) ( $buffer[26] + ".maxValue" );

			// create ramp for opacityInputBiasPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[26] + ".computeNodeColor" )`;
			$buffer[27] = $temp[0];

			setAttr ( $buffer[27] + ".colorEntryList[0].color" ) 0 0 0;
			removeMultiInstance -break true ( $buffer[27] + ".colorEntryList[1]" );
			removeMultiInstance -break true ( $buffer[27] + ".colorEntryList[2]" );

			// create connections between particleSamplerInfo and opacityInputBiasPP

			connectAttr -f ( $buffer[13] + ".userVector1PPZ" ) ( $buffer[12] + ".opacityInputBias" );

			// set expressions

			$explression = "radiusPP = clamp ( radiusMin * radiusMinPP, radiusMax * radiusMaxPP, 0.1 * radius * radiusStartPP );\n";
			$explression += "userVector3PP = << textureOriginPP, 0, 0 >>;";

			dynExpression -s $explression -c $buffer[2];

			$explression = "velocity += sphrand ( velocityRand );\n";
			$explression += "radiusPP = clamp ( radiusMin * radiusMinPP, radiusMax * radiusMaxPP, radiusPP + 0.01 * radiusMultPP * radiusMult );\n";
			$explression += "userVector1PP = << colorInputBiasPP, incandescenceInputBiasPP, opacityInputBiasPP >>;\n";
			$explression += "userVector2PP = << amplitudePP, textureTimePP, textureScalePP >>;";

			string $ver = `about -v`;

			if ( int ( substring ( $ver, 1, 1 ) ) > 5 )
			{
				dynExpression -s $explression -rbd $buffer[2];
			}
			else
			{
				dynExpression -s $explression -r $buffer[2];
			}

			string $groupName = `group -n "explosion#" $buffer[0] $buffer[1] $buffer[12]`;
			string $tok[];
			tokenize $groupName "n" $tok;

			// rename nodes

			rename $buffer[0] ( "exp" + $tok[1] + "_emitter" );
			rename $buffer[1] ( "exp" + $tok[1] + "_particle" );
			rename $buffer[3] ( "exp" + $tok[1] + "_radMultPP_aMapper" );
			rename $buffer[4] ( "exp" + $tok[1] + "_radMultPP_ramp" );
			rename $buffer[5] ( "exp" + $tok[1] + "_radStartPP_aMapper" );
			rename $buffer[6] ( "exp" + $tok[1] + "_radStartPP_ramp" );
			rename $buffer[7] ( "exp" + $tok[1] + "_opacPP_aMapper" );
			rename $buffer[8] ( "exp" + $tok[1] + "_opacPP_ramp" );
			rename $buffer[12] ( "exp" + $tok[1] + "_fluid" );
			rename $buffer[14] ( "exp" + $tok[1] + "_texOrigPP_aMapper" );
			rename $buffer[15] ( "exp" + $tok[1] + "_texOrigPP_ramp" );
			rename $buffer[16] ( "exp" + $tok[1] + "_texScalePP_aMapper" );
			rename $buffer[17] ( "exp" + $tok[1] + "_texScalePP_ramp" );
			rename $buffer[18] ( "exp" + $tok[1] + "_incanInBiasPP_aMapper" );
			rename $buffer[19] ( "exp" + $tok[1] + "_incanInBiasPP_ramp" );
			rename $buffer[20] ( "exp" + $tok[1] + "_texTimePP_aMapper" );
			rename $buffer[21] ( "exp" + $tok[1] + "_texTimePP_ramp" );
			rename $buffer[22] ( "exp" + $tok[1] + "_ampPP_aMapper" );
			rename $buffer[23] ( "exp" + $tok[1] + "_ampPP_ramp" );
			rename $buffer[24] ( "exp" + $tok[1] + "_colorInBiasPP_aMapper" );
			rename $buffer[25] ( "exp" + $tok[1] + "_colorInBiasPP_ramp" );
			rename $buffer[26] ( "exp" + $tok[1] + "_opacInBiasPP_aMapper" );
			rename $buffer[27] ( "exp" + $tok[1] + "_opacInBiasPP_ramp" );
			rename $buffer[28] ( "exp" + $tok[1] + "_radMinPP_aMapper" );
			rename $buffer[29] ( "exp" + $tok[1] + "_radMinPP_ramp" );
			rename $buffer[30] ( "exp" + $tok[1] + "_radMaxPP_aMapper" );
			rename $buffer[31] ( "exp" + $tok[1] + "_radMaxPP_ramp" );

			break;

		// #################################################################################################
		// #    CREATE BIG TENDRILS									   					    #
		// #################################################################################################

		case "tendBig":
			string $buffer[], $temp[], $explression;

			// create emitter

			$temp = `emitter -pos 0 0 0 -type omni -r 100 -sro 0 -nuv 0 -cye none -cyi 1 -spd 1 -srn 0 -nsp 1 -tsp 0 -mxd 0 -mnd 0 -dx 1 -dy 0 -dz 0 -sp 0`;
			$buffer[0] = $temp[0];

			// set emission attributes

			setAttr ( $buffer[0] + ".scale" ) 2 2 2;
			setAttr ( $buffer[0] + ".rate" ) 5;
			setAttr ( $buffer[0] + ".speedRandom" ) 3;
			setAttr ( $buffer[0] + ".awayFromCenter" ) 1;
			setAttr ( $buffer[0] + ".randomDirection" ) 1;
			setAttr ( $buffer[0] + ".directionalSpeed" ) 1;
			setAttr ( $buffer[0] + ".emitterType" ) 4;
			setAttr ( $buffer[0] + ".volumeShape" ) 1;
			setAttr ( $buffer[0] + ".directionX" ) 0;

			$temp = `particle`;
			$buffer[9] = $temp[0];
			$buffer[11] = $temp[1];

			// connect leadParticleShape to emitter

			connectDynamic -em $buffer[0] $buffer[9];

			// manage leadParticleShape attributes

			setAttr ( $buffer[11] + ".conserve" ) 0.97;
			setAttr ( $buffer[11] + ".particleRenderType" ) 2;
			addAttr -ln velocityRand -at double -smn 0 -smx 2 -dv 0.1 $buffer[11];

			string $ver = `about -v`;

			if ( int ( substring ( $ver, 1, 1 ) ) > 5 )
			{
				dynExpression -s "velocity = velocity + sphrand ( velocityRand )" -rbd $buffer[11];
			}
			else
			{
				dynExpression -s "velocity = velocity + sphrand ( velocityRand )" -r $buffer[11];
			}

			// create leadParticleShape emitter

			select $buffer[9];
			$temp = `emitter -type omni -r 100 -sro 0 -nuv 0 -cye none -cyi 1 -spd 1 -srn 0 -nsp 1 -tsp 0 -mxd 0 -mnd 0 -dx 1 -dy 0 -dz 0 -sp 0`;
			$buffer[10] = $temp[1];

			// set leadParticleShape emitter attribtues

			setAttr ( $buffer[10] + ".rate" ) 5;
			setAttr ( $buffer[10] + ".speed" ) 0;

			// create trailsParticleShape

			$temp = `particle`;
			$buffer[1] = $temp[0];
			$buffer[2] = $temp[1];

			// connect trailsParticleShape to leadParticleShape emitter

			connectDynamic -em $buffer[10] $buffer[2];

			// manage trailsParticleShape attributes

			setAttr ( $buffer[2] + ".conserve" ) 0.995;
			setAttr ( $buffer[2] + ".lifespanMode" ) 2;
			setAttr ( $buffer[2] + ".lifespan" ) 10;
			setAttr ( $buffer[2] + ".lifespanRandom" ) 1;
			setAttr ( $buffer[2] + ".particleRenderType" ) 8;
			addAttr -is true -ln "betterIllumination" -at bool -dv false $buffer[2];
			addAttr -is true -ln "surfaceShading" -at "float" -smn 0 -smx 1 -dv 0 $buffer[2];
			addAttr -is true -ln "threshold" -at "float" -smn 0 -smx 10 -dv 0 $buffer[2];
			addAttr -is true -ln "radius" -at "float" -smn 0 -smx 20 -dv 2 $buffer[2];
			addAttr -ln radiusPP -dt doubleArray $buffer[2];
			addAttr -ln radiusMultPP -dt doubleArray $buffer[2];
			addAttr -ln radiusStartPP -dt doubleArray $buffer[2];
			addAttr -ln radiusMinPP -dt doubleArray $buffer[2];
			addAttr -ln radiusMaxPP -dt doubleArray $buffer[2];
			addAttr -ln opacityPP -dt doubleArray $buffer[2];
			addAttr -ln colorInputBiasPP -dt doubleArray $buffer[2];
			addAttr -ln incandescenceInputBiasPP -dt doubleArray $buffer[2];
			addAttr -ln opacityInputBiasPP -dt doubleArray $buffer[2];
			addAttr -ln amplitudePP -dt doubleArray $buffer[2];
			addAttr -ln textureTimePP -dt doubleArray $buffer[2];
			addAttr -ln textureScalePP -dt doubleArray $buffer[2];
			addAttr -ln textureOriginPP -dt doubleArray $buffer[2];
			addAttr -ln userVector1PP -dt vectorArray $buffer[2];
			addAttr -ln userVector2PP -dt vectorArray $buffer[2];
			addAttr -ln userVector3PP -dt vectorArray $buffer[2];
			addAttr -ln velocityRand -at double -smn 0 -smx 2 -dv 0.05 $buffer[2];
			addAttr -ln radiusMult -at double -smn 0 -smx 20 -dv 5 $buffer[2];
			addAttr -ln radiusMin -at double -smn 0 -smx 20 -dv 0 $buffer[2];
			addAttr -ln radiusMax -at double -smn 0 -smx 20 -dv 2 $buffer[2];
			addAttr -ln colorInputBiasMin -at double -smn -1 -smx 1 -dv 0 $buffer[2];
			addAttr -ln colorInputBiasMax -at double -smn -1 -smx 1 -dv 0 $buffer[2];
			addAttr -ln incandescenceInputBiasMin -at double -smn -1 -smx 1 -dv -1 $buffer[2];
			addAttr -ln incandescenceInputBiasMax -at double -smn -1 -smx 1 -dv 1 $buffer[2];
			addAttr -ln opacityInputBiasMin -at double -smn -1 -smx 1 -dv 0 $buffer[2];
			addAttr -ln opacityInputBiasMax -at double -smn -1 -smx 1 -dv 0 $buffer[2];
			addAttr -ln amplitudeMin -at double -smn 0 -smx 1 -dv 0.4 $buffer[2];
			addAttr -ln amplitudeMax -at double -smn 0 -smx 3 -dv 2.5 $buffer[2];
			addAttr -ln textureTimeMin -at double -smn 0 -smx 1 -dv 0 $buffer[2];
			addAttr -ln textureTimeMax -at double -smn 0 -smx 1 -dv 1 $buffer[2];
			addAttr -ln textureScaleMin -at double -smn 0 -smx 10 -dv 0.4 $buffer[2];
			addAttr -ln textureScaleMax -at double -smn 0 -smx 10 -dv 1 $buffer[2];
			addAttr -ln textureOriginMin -at double -smn 0 -smx 2 -dv 0 $buffer[2];
			addAttr -ln textureOriginMax -at double -smn 0 -smx 2 -dv 1 $buffer[2];

			// create fluidShape

			$buffer[12] = `create3DFluid 20 20 20 10 10 10`;

			// MAYA 5.0 COMPATIBILITY ( THE NEXT TWO LINES ARE NOT NEEDED FOR MAYA 6+ )
			//
			$temp = `ls -sl`;
			$buffer[12] = $temp[0];

			// manage fluidShape attributes

			setAttr ( $buffer[12] + ".densityMethod" ) 3;
			setAttr ( $buffer[12] + ".densityGradient" ) 11;
			setAttr ( $buffer[12] + ".velocityMethod" ) 0;
			setAttr ( $buffer[12] + ".boundaryDraw" ) 4;
			setAttr ( $buffer[12] + ".wireframeDisplay" ) 0;
			setAttr ( $buffer[12] + ".dropoffShape" ) 1;
			setAttr ( $buffer[12] + ".edgeDropoff" ) 0.35;
			setAttr ( $buffer[12] + ".quality" ) 0.5;
			setAttr ( $buffer[12] + ".renderInterpolator" ) 3;
			setAttr ( $buffer[12] + ".colorTexture" ) 1;
			setAttr ( $buffer[12] + ".incandTexture" ) 1;
			setAttr ( $buffer[12] + ".opacityTexture" ) 1;
			setAttr ( $buffer[12] + ".textureType" ) 4;
			setAttr ( $buffer[12] + ".colorTexGain" ) 0.175;
			setAttr ( $buffer[12] + ".incandTexGain" ) 1.049;
			setAttr ( $buffer[12] + ".opacityTexGain" ) 0.547;
			setAttr ( $buffer[12] + ".color[0].color_Color" ) 0 0 0;
			setAttr ( $buffer[12] + ".colorInput" ) 4;
			setAttr ( $buffer[12] + ".incandescence[0].incandescence_Position" ) 0.029;
			setAttr ( $buffer[12] + ".incandescence[0].incandescence_Color" ) 0.15 0.15 0.15;
			setAttr ( $buffer[12] + ".incandescence[1].incandescence_Position" ) 0.193;
			setAttr ( $buffer[12] + ".incandescence[1].incandescence_Color" ) 0.425 0.056145 0.0221;
			setAttr ( $buffer[12] + ".incandescence[1].incandescence_Interp" ) 3;
			setAttr ( $buffer[12] + ".incandescence[2].incandescence_Position" ) 0.471;
			setAttr ( $buffer[12] + ".incandescence[2].incandescence_Color" ) 0.784 0.1279 0.046256;
			setAttr ( $buffer[12] + ".incandescence[2].incandescence_Interp" ) 2;
			setAttr ( $buffer[12] + ".incandescence[3].incandescence_Position" ) 0.664;
			setAttr ( $buffer[12] + ".incandescence[3].incandescence_Color" ) 1.747 0.361157 0.092591;
			setAttr ( $buffer[12] + ".incandescence[3].incandescence_Interp" ) 3;
			setAttr ( $buffer[12] + ".incandescence[4].incandescence_Color" ) 4 1.012111 0.276;
			setAttr ( $buffer[12] + ".incandescence[4].incandescence_Position" ) 1;
			setAttr ( $buffer[12] + ".incandescence[4].incandescence_Interp" ) 2;
			setAttr ( $buffer[12] + ".incandescenceInput" ) 4;
			setAttr ( $buffer[12] + ".opacity[0].opacity_Position" ) 0.164;
			setAttr ( $buffer[12] + ".opacity[1].opacity_FloatValue" ) 0.003;
			setAttr ( $buffer[12] + ".opacity[1].opacity_Position" ) 0.293;
			setAttr ( $buffer[12] + ".opacity[1].opacity_Interp" ) 1;
			setAttr ( $buffer[12] + ".opacity[2].opacity_FloatValue" ) 0.340;
			setAttr ( $buffer[12] + ".opacity[2].opacity_Position" ) 0.343;
			setAttr ( $buffer[12] + ".opacity[2].opacity_Interp" ) 1;
			setAttr ( $buffer[12] + ".opacity[3].opacity_FloatValue" ) 0.640;
			setAttr ( $buffer[12] + ".opacity[3].opacity_Position" ) 0.464;
			setAttr ( $buffer[12] + ".opacity[3].opacity_Interp" ) 1;
			setAttr ( $buffer[12] + ".opacity[4].opacity_FloatValue" ) 0.780;
			setAttr ( $buffer[12] + ".opacity[4].opacity_Position" ) 0.693;
			setAttr ( $buffer[12] + ".opacity[4].opacity_Interp" ) 1;
			setAttr ( $buffer[12] + ".ratio" ) 0.524;
			setAttr ( $buffer[12] + ".frequencyRatio" ) 1.961;
			setAttr ( $buffer[12] + ".depthMax" ) 4;
			setAttr ( $buffer[12] + ".inflection" ) 1;
			setAttr ( $buffer[12] + ".frequency" ) 2.184;
			setAttr ( $buffer[12] + ".textureScaleX" ) 5.5;
			setAttr ( $buffer[12] + ".textureScaleY" ) 5.5;
			setAttr ( $buffer[12] + ".textureScaleZ" ) 5.5;
			setAttr ( $buffer[12] + ".realLights" ) 0;
			setAttr ( $buffer[12] + ".castsShadows" ) 0;
			setAttr ( $buffer[12] + ".receiveShadows" ) 0;
			setAttr ( $buffer[12] + ".primaryVisibility" ) 0;
			setAttr ( $buffer[12] + ".visibleInReflections" ) 0;
			setAttr ( $buffer[12] + ".visibleInRefractions" ) 0;

			// assign fluidShape to trailsParticleShape

			$temp = `listConnections -s 0 -d 1 ( $buffer[12] + ".outColor" )`;
			select $buffer[2];
			sets -e -forceElement $temp[0];

			// create particleSamplerInfo

			$buffer[13] = `shadingNode -asUtility particleSamplerInfo`;

			// create arrayMapper for radiusMultPP

			$temp = `arrayMapper -target $buffer[2] -destAttr radiusMultPP -inputV ageNormalized -type ramp`;
			$buffer[3] = $temp[0];

			// create ramp for radiusMultPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[3] + ".computeNodeColor" )`;
			$buffer[4] = $temp[0];

			setAttr ( $buffer[4] + ".colorEntryList[0].color" ) 0.5 0.5 0.5;
			removeMultiInstance -break true ( $buffer[4] + ".colorEntryList[1]" );
			setAttr ( $buffer[4] + ".colorEntryList[2].color" ) 1 1 1;

			// create arrayMapper for radiusStartPP

			$temp = `arrayMapper -target $buffer[2] -destAttr radiusStartPP -inputV ageNormalized -type ramp`;
			$buffer[5] = $temp[0];

			// create ramp for radiusStartPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[5] + ".computeNodeColor" )`;
			$buffer[6] = $temp[0];

			setAttr ( $buffer[6] + ".colorEntryList[0].color" ) 0.9 0.9 0.9;
			removeMultiInstance -break true ( $buffer[6] + ".colorEntryList[1]" );
			setAttr ( $buffer[6] + ".colorEntryList[2].color" ) 1 1 1;
			setAttr ( $buffer[6] + ".colorEntryList[2].position" ) 1;
			setAttr ( $buffer[6] + ".noise" ) 1;

			// create arrayMapper for radiusMinPP

			$temp = `arrayMapper -target $buffer[2] -destAttr radiusMinPP -inputV birthTime -type ramp`;
			$buffer[28] = $temp[0];

			// create ramp for radiusMinPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[28] + ".computeNodeColor" )`;
			$buffer[29] = $temp[0];

			setAttr ( $buffer[29] + ".colorEntryList[0].color" ) 1 1 1;
			removeMultiInstance -break true ( $buffer[29] + ".colorEntryList[1]" );
			removeMultiInstance -break true ( $buffer[29] + ".colorEntryList[2]" );
			setAttr ( $buffer[29] + ".noise" ) 1;

			// create arrayMapper for radiusMaxPP

			$temp = `arrayMapper -target $buffer[2] -destAttr radiusMaxPP -inputV birthTime -type ramp`;
			$buffer[30] = $temp[0];

			// create ramp for radiusMaxPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[30] + ".computeNodeColor" )`;
			$buffer[31] = $temp[0];

			setAttr ( $buffer[31] + ".colorEntryList[0].color" ) 1 1 1;
			removeMultiInstance -break true ( $buffer[31] + ".colorEntryList[1]" );
			removeMultiInstance -break true ( $buffer[31] + ".colorEntryList[2]" );
			setAttr ( $buffer[31] + ".noise" ) 1;

			// create arrayMapper for opacityPP

			$temp = `arrayMapper -target $buffer[2] -destAttr opacityPP -inputV ageNormalized -type ramp`;
			$buffer[7] = $temp[0];

			// create ramp for opacityPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[7] + ".computeNodeColor" )`;
			$buffer[8] = $temp[0];

			setAttr ( $buffer[8] + ".colorEntryList[0].color" ) 0 0 0;
			removeMultiInstance -break true ( $buffer[8] + ".colorEntryList[1]" );
			removeMultiInstance -break true ( $buffer[8] + ".colorEntryList[2]" );

			// create connections between particleSamplerInfo and opacityPP

			connectAttr -f ( $buffer[13] + ".opacityPP" ) ( $buffer[12] + ".transparencyR" );
			connectAttr -f ( $buffer[13] + ".opacityPP" ) ( $buffer[12] + ".transparencyG" );
			connectAttr -f ( $buffer[13] + ".opacityPP" ) ( $buffer[12] + ".transparencyB" );

			// create arrayMapper for textureOriginPP

			$temp = `arrayMapper -target $buffer[2] -destAttr textureOriginPP -inputV ageNormalized -type ramp`;
			$buffer[14] = $temp[0];

			connectAttr -f ( $buffer[2] + ".textureOriginMin" ) ( $buffer[14] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".textureOriginMax" ) ( $buffer[14] + ".maxValue" );

			// create ramp for textureOriginPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[14] + ".computeNodeColor" )`;
			$buffer[15] = $temp[0];

			setAttr ( $buffer[15] + ".colorEntryList[0].color" ) 1 1 1;
			removeMultiInstance -break true ( $buffer[15] + ".colorEntryList[1]" );
			setAttr ( $buffer[15] + ".colorEntryList[2].color" ) 0 0 0;
			setAttr ( $buffer[15] + ".colorEntryList[2].position" ) 1;
			setAttr ( $buffer[15] + ".noise" ) 1;

			// create connections between particleSamplerInfo and textureOriginPP

			connectAttr -f ( $buffer[13] + ".userVector3PPX" ) ( $buffer[12] + ".textureOriginX" );
			connectAttr -f ( $buffer[13] + ".userVector3PPX" ) ( $buffer[12] + ".textureOriginY" );
			connectAttr -f ( $buffer[13] + ".userVector3PPX" ) ( $buffer[12] + ".textureOriginZ" );

			// create arrayMapper for textureScalePP

			$temp = `arrayMapper -target $buffer[2] -destAttr textureScalePP -inputV ageNormalized -type ramp`;
			$buffer[16] = $temp[0];

			connectAttr -f ( $buffer[2] + ".textureScaleMin" ) ( $buffer[16] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".textureScaleMax" ) ( $buffer[16] + ".maxValue" );

			// create ramp for textureScalePP

			$temp = `listConnections -s 1 -d 0 ( $buffer[16] + ".computeNodeColor" )`;
			$buffer[17] = $temp[0];

			setAttr ( $buffer[17] + ".colorEntryList[0].color" ) 1 1 1;
			removeMultiInstance -break true ( $buffer[17] + ".colorEntryList[1]" );
			setAttr ( $buffer[17] + ".colorEntryList[2].color" ) 0.5 0.5 0.5;
			setAttr ( $buffer[17] + ".colorEntryList[2].position" ) 1;

			// create connections between particleSamplerInfo and textureScalePP

			connectAttr -f ( $buffer[13] + ".userVector2PPZ" ) ( $buffer[12] + ".textureScaleX" );
			connectAttr -f ( $buffer[13] + ".userVector2PPZ" ) ( $buffer[12] + ".textureScaleY" );
			connectAttr -f ( $buffer[13] + ".userVector2PPZ" ) ( $buffer[12] + ".textureScaleZ" );

			// create arrayMapper for incandescenceInputBiasPP

			$temp = `arrayMapper -target $buffer[2] -destAttr incandescenceInputBiasPP -inputV ageNormalized -type ramp`;
			$buffer[18] = $temp[0];

			connectAttr -f ( $buffer[2] + ".incandescenceInputBiasMin" ) ( $buffer[18] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".incandescenceInputBiasMax" ) ( $buffer[18] + ".maxValue" );

			// create ramp for incandescenceInputBiasPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[18] + ".computeNodeColor" )`;
			$buffer[19] = $temp[0];

			setAttr ( $buffer[19] + ".interpolation" ) 3;
			setAttr ( $buffer[19] + ".colorEntryList[0].color" ) 0.85 0.85 0.85;
			setAttr ( $buffer[19] + ".colorEntryList[1].color" ) 0.5 0.5 0.5;
			setAttr ( $buffer[19] + ".colorEntryList[1].position" ) 0.1;
			setAttr ( $buffer[19] + ".colorEntryList[2].color" ) 0 0 0;
			setAttr ( $buffer[19] + ".colorEntryList[2].position" ) 1;

			// create connections between particleSamplerInfo and incandescenceInputBiasPP

			connectAttr -f ( $buffer[13] + ".userVector1PPY" ) ( $buffer[12] + ".incandescenceInputBias" );

			// create arrayMapper for textureTimePP

			$temp = `arrayMapper -target $buffer[2] -destAttr textureTimePP -inputV ageNormalized -type ramp`;
			$buffer[20] = $temp[0];

			connectAttr -f ( $buffer[2] + ".textureTimeMin" ) ( $buffer[20] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".textureTimeMax" ) ( $buffer[20] + ".maxValue" );

			// create ramp for textureTimePP

			$temp = `listConnections -s 1 -d 0 ( $buffer[20] + ".computeNodeColor" )`;
			$buffer[21] = $temp[0];

			setAttr ( $buffer[21] + ".interpolation" ) 3;
			setAttr ( $buffer[21] + ".colorEntryList[0].color" ) 0 0 0;
			removeMultiInstance -break true ( $buffer[21] + ".colorEntryList[1]" );
			setAttr ( $buffer[21] + ".colorEntryList[2].color" ) 0.75 0.75 0.75;
			setAttr ( $buffer[21] + ".colorEntryList[2].position" ) 1;

			// create connections between particleSamplerInfo and textureTimePP

			connectAttr -f ( $buffer[13] + ".userVector2PPY" ) ( $buffer[12] + ".textureTime" );

			// create arrayMapper for amplitudePP

			$temp = `arrayMapper -target $buffer[2] -destAttr amplitudePP -inputV ageNormalized -type ramp`;
			$buffer[22] = $temp[0];

			connectAttr -f ( $buffer[2] + ".amplitudeMin" ) ( $buffer[22] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".amplitudeMax" ) ( $buffer[22] + ".maxValue" );

			// create ramp for amplitudePP

			$temp = `listConnections -s 1 -d 0 ( $buffer[22] + ".computeNodeColor" )`;
			$buffer[23] = $temp[0];

			setAttr ( $buffer[23] + ".colorEntryList[0].color" ) 0 0 0;
			removeMultiInstance -break true ( $buffer[23] + ".colorEntryList[1]" );
			setAttr ( $buffer[23] + ".colorEntryList[2].color" ) 1 1 1;
			setAttr ( $buffer[23] + ".colorEntryList[2].position" ) 1;

			// create connections between particleSamplerInfo and amplitudePP

			connectAttr -f ( $buffer[13] + ".userVector2PPX" ) ( $buffer[12] + ".amplitude" );

			// create arrayMapper for colorInputBiasPP

			$temp = `arrayMapper -target $buffer[2] -destAttr colorInputBiasPP -inputV ageNormalized -type ramp`;
			$buffer[24] = $temp[0];

			connectAttr -f ( $buffer[2] + ".colorInputBiasMin" ) ( $buffer[24] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".colorInputBiasMax" ) ( $buffer[24] + ".maxValue" );

			// create ramp for colorInputBiasPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[24] + ".computeNodeColor" )`;
			$buffer[25] = $temp[0];

			setAttr ( $buffer[25] + ".colorEntryList[0].color" ) 0 0 0;
			removeMultiInstance -break true ( $buffer[25] + ".colorEntryList[1]" );
			removeMultiInstance -break true ( $buffer[25] + ".colorEntryList[2]" );

			// create connections between particleSamplerInfo and colorInputBiasPP

			connectAttr -f ( $buffer[13] + ".userVector1PPX" ) ( $buffer[12] + ".colorInputBias" );

			// create arrayMapper for opacityInputBiasPP

			$temp = `arrayMapper -target $buffer[2] -destAttr opacityInputBiasPP -inputV ageNormalized -type ramp`;
			$buffer[26] = $temp[0];

			connectAttr -f ( $buffer[2] + ".opacityInputBiasMin" ) ( $buffer[26] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".opacityInputBiasMax" ) ( $buffer[26] + ".maxValue" );

			// create ramp for opacityInputBiasPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[26] + ".computeNodeColor" )`;
			$buffer[27] = $temp[0];

			setAttr ( $buffer[27] + ".colorEntryList[0].color" ) 0 0 0;
			removeMultiInstance -break true ( $buffer[27] + ".colorEntryList[1]" );
			removeMultiInstance -break true ( $buffer[27] + ".colorEntryList[2]" );

			// create connections between particleSamplerInfo and opacityInputBiasPP

			connectAttr -f ( $buffer[13] + ".userVector1PPZ" ) ( $buffer[12] + ".opacityInputBias" );

			// set expressions

			$explression = "radiusPP = clamp ( radiusMin * radiusMinPP, radiusMax * radiusMaxPP, 0.1 * radius * radiusStartPP );\n";
			$explression += "userVector3PP = << textureOriginPP, 0, 0 >>;";

			dynExpression -s $explression -c $buffer[2];

			$explression = "velocity += sphrand ( velocityRand );\n";
			$explression += "radiusPP = clamp ( radiusMin * radiusMinPP, radiusMax * radiusMaxPP, radiusPP + 0.01 * radiusMultPP * radiusMult );\n";
			$explression += "userVector1PP = << colorInputBiasPP, incandescenceInputBiasPP, opacityInputBiasPP >>;\n";
			$explression += "userVector2PP = << amplitudePP, textureTimePP, textureScalePP >>;";

			string $ver = `about -v`;

			if ( int ( substring ( $ver, 1, 1 ) ) > 5 )
			{
				dynExpression -s $explression -rbd $buffer[2];
			}
			else
			{
				dynExpression -s $explression -r $buffer[2];
			}

			string $groupName = `group -n "tendrils_big#" $buffer[0] $buffer[1] $buffer[9] $buffer[12]`;
			string $tok[];
			tokenize $groupName "g" $tok;

			// rename nodes

			rename $buffer[0] ( "tendBig" + $tok[1] + "_leadEmitter" );
			rename $buffer[1] ( "tendBig" + $tok[1] + "_trailParticle" );
			rename $buffer[3] ( "tendBig" + $tok[1] + "_radMultPP_aMapper" );
			rename $buffer[4] ( "tendBig" + $tok[1] + "_radMultPP_ramp" );
			rename $buffer[5] ( "tendBig" + $tok[1] + "_radStartPP_aMapper" );
			rename $buffer[6] ( "tendBig" + $tok[1] + "_radStartPP_ramp" );
			rename $buffer[7] ( "tendBig" + $tok[1] + "_opacPP_aMapper" );
			rename $buffer[8] ( "tendBig" + $tok[1] + "_opacPP_ramp" );
			rename $buffer[9] ( "tendBig" + $tok[1] + "_leadParticle" );
			rename $buffer[10] ( "tendBig" + $tok[1] + "_trailEmitter" );
			rename $buffer[12] ( "tendBig" + $tok[1] + "_fluid" );
			rename $buffer[14] ( "tendBig" + $tok[1] + "_texOrigPP_aMapper" );
			rename $buffer[15] ( "tendBig" + $tok[1] + "_texOrigPP_ramp" );
			rename $buffer[16] ( "tendBig" + $tok[1] + "_texScalePP_aMapper" );
			rename $buffer[17] ( "tendBig" + $tok[1] + "_texScalePP_ramp" );
			rename $buffer[18] ( "tendBig" + $tok[1] + "_incanInBiasPP_aMapper" );
			rename $buffer[19] ( "tendBig" + $tok[1] + "_incanInBiasPP_ramp" );
			rename $buffer[20] ( "tendBig" + $tok[1] + "_texTimePP_aMapper" );
			rename $buffer[21] ( "tendBig" + $tok[1] + "_texTimePP_ramp" );
			rename $buffer[22] ( "tendBig" + $tok[1] + "_ampPP_aMapper" );
			rename $buffer[23] ( "tendBig" + $tok[1] + "_ampPP_ramp" );
			rename $buffer[24] ( "tendBig" + $tok[1] + "_colorInBiasPP_aMapper" );
			rename $buffer[25] ( "tendBig" + $tok[1] + "_colorInBiasPP_ramp" );
			rename $buffer[26] ( "tendBig" + $tok[1] + "_opacInBiasPP_aMapper" );
			rename $buffer[27] ( "tendBig" + $tok[1] + "_opacInBiasPP_ramp" );
			rename $buffer[28] ( "tendBig" + $tok[1] + "_radMinPP_aMapper" );
			rename $buffer[29] ( "tendBig" + $tok[1] + "_radMinPP_ramp" );
			rename $buffer[30] ( "tendBig" + $tok[1] + "_radMaxPP_aMapper" );
			rename $buffer[31] ( "tendBig" + $tok[1] + "_radMaxPP_ramp" );

			break;

		// #################################################################################################
		// #    CREATE SMALL TENDRILS									   					    #
		// #################################################################################################

		case "tendSmall":
			string $buffer[], $temp[], $explression;

			// create emitter

			$temp = `emitter -pos 0 0 0 -type omni -r 100 -sro 0 -nuv 0 -cye none -cyi 1 -spd 1 -srn 0 -nsp 1 -tsp 0 -mxd 0 -mnd 0 -dx 1 -dy 0 -dz 0 -sp 0`;
			$buffer[0] = $temp[0];

			// set emission attributes

			currentTime 79;
			setKeyframe -v 5 ( $buffer[0] + ".rate" );
			currentTime 80;
			setKeyframe -v 0 ( $buffer[0] + ".rate" );
			currentTime 1;
			setAttr ( $buffer[0] + ".speedRandom" ) 3;
			setAttr ( $buffer[0] + ".awayFromCenter" ) 7.5;
			setAttr ( $buffer[0] + ".randomDirection" ) 1;
			setAttr ( $buffer[0] + ".directionalSpeed" ) 1;
			setAttr ( $buffer[0] + ".emitterType" ) 4;
			setAttr ( $buffer[0] + ".volumeShape" ) 1;
			setAttr ( $buffer[0] + ".directionX" ) 0;

			// create leadParticle and leadParticleShape

			$temp = `particle`;
			$buffer[9] = $temp[0];
			$buffer[11] = $temp[1];

			// connect leadParticleShape to emitter

			connectDynamic -em $buffer[0] $buffer[9];

			// manage leadParticleShape attributes

			setAttr ( $buffer[11] + ".conserve" ) 0.995;
			setAttr ( $buffer[11] + ".particleRenderType" ) 2;
			addAttr -ln velocityRand -at double -smn 0 -smx 2 -dv 0.325 $buffer[11];

			string $ver = `about -v`;

			if ( int ( substring ( $ver, 1, 1 ) ) > 5 )
			{
				dynExpression -s "velocity = velocity + sphrand ( velocityRand )" -rbd $buffer[11];
			}
			else
			{
				dynExpression -s "velocity = velocity + sphrand ( velocityRand )" -r $buffer[11];
			}

			// create leadParticleShape emitter

			select $buffer[9];
			$temp = `emitter -type omni -r 100 -sro 0 -nuv 0 -cye none -cyi 1 -spd 1 -srn 0 -nsp 1 -tsp 0 -mxd 0 -mnd 0 -dx 1 -dy 0 -dz 0 -sp 0`;
			$buffer[10] = $temp[1];

			// set leadParticleShape emitter attribtues

			setAttr ( $buffer[10] + ".rate" ) 60;
			setAttr ( $buffer[10] + ".speed" ) 0;

			// create trailsParticleShape

			$temp = `particle`;
			$buffer[1] = $temp[0];
			$buffer[2] = $temp[1];

			// connect trailsParticleShape to leadParticleShape emitter

			connectDynamic -em $buffer[10] $buffer[2];

			// manage trailsParticleShape attributes

			setAttr ( $buffer[2] + ".conserve" ) 0.995;
			setAttr ( $buffer[2] + ".lifespanMode" ) 2;
			setAttr ( $buffer[2] + ".lifespan" ) 10;
			setAttr ( $buffer[2] + ".lifespanRandom" ) 1;
			setAttr ( $buffer[2] + ".particleRenderType" ) 8;
			addAttr -is true -ln "betterIllumination" -at bool -dv false $buffer[2];
			addAttr -is true -ln "surfaceShading" -at "float" -smn 0 -smx 1 -dv 0 $buffer[2];
			addAttr -is true -ln "threshold" -at "float" -smn 0 -smx 10 -dv 0 $buffer[2];
			addAttr -is true -ln "radius" -at "float" -smn 0 -smx 20 -dv 2 $buffer[2];
			addAttr -ln radiusPP -dt doubleArray $buffer[2];
			addAttr -ln radiusMultPP -dt doubleArray $buffer[2];
			addAttr -ln radiusStartPP -dt doubleArray $buffer[2];
			addAttr -ln radiusMinPP -dt doubleArray $buffer[2];
			addAttr -ln radiusMaxPP -dt doubleArray $buffer[2];
			addAttr -ln opacityPP -dt doubleArray $buffer[2];
			addAttr -ln colorInputBiasPP -dt doubleArray $buffer[2];
			addAttr -ln incandescenceInputBiasPP -dt doubleArray $buffer[2];
			addAttr -ln opacityInputBiasPP -dt doubleArray $buffer[2];
			addAttr -ln amplitudePP -dt doubleArray $buffer[2];
			addAttr -ln textureTimePP -dt doubleArray $buffer[2];
			addAttr -ln textureScalePP -dt doubleArray $buffer[2];
			addAttr -ln textureOriginPP -dt doubleArray $buffer[2];
			addAttr -ln userVector1PP -dt vectorArray $buffer[2];
			addAttr -ln userVector2PP -dt vectorArray $buffer[2];
			addAttr -ln userVector3PP -dt vectorArray $buffer[2];
			addAttr -ln velocityRand -at double -smn 0 -smx 2 -dv 0.05 $buffer[2];
			addAttr -ln radiusMult -at double -smn 0 -smx 20 -dv 1.5 $buffer[2];
			addAttr -ln radiusMin -at double -smn 0 -smx 20 -dv 0 $buffer[2];
			addAttr -ln radiusMax -at double -smn 0 -smx 20 -dv 2 $buffer[2];
			addAttr -ln colorInputBiasMin -at double -smn -1 -smx 1 -dv 0 $buffer[2];
			addAttr -ln colorInputBiasMax -at double -smn -1 -smx 1 -dv 0 $buffer[2];
			addAttr -ln incandescenceInputBiasMin -at double -smn -1 -smx 1 -dv -1 $buffer[2];
			addAttr -ln incandescenceInputBiasMax -at double -smn -1 -smx 1 -dv 1 $buffer[2];
			addAttr -ln opacityInputBiasMin -at double -smn -1 -smx 1 -dv 0 $buffer[2];
			addAttr -ln opacityInputBiasMax -at double -smn -1 -smx 1 -dv 0 $buffer[2];
			addAttr -ln amplitudeMin -at double -smn 0 -smx 1 -dv 0.4 $buffer[2];
			addAttr -ln amplitudeMax -at double -smn 0 -smx 3 -dv 2.5 $buffer[2];
			addAttr -ln textureTimeMin -at double -smn 0 -smx 1 -dv 0 $buffer[2];
			addAttr -ln textureTimeMax -at double -smn 0 -smx 1 -dv 1 $buffer[2];
			addAttr -ln textureScaleMin -at double -smn 0 -smx 10 -dv 0 $buffer[2];
			addAttr -ln textureScaleMax -at double -smn 0 -smx 10 -dv 1.5 $buffer[2];
			addAttr -ln textureOriginMin -at double -smn 0 -smx 2 -dv 0 $buffer[2];
			addAttr -ln textureOriginMax -at double -smn 0 -smx 2 -dv 1 $buffer[2];

			// create fluidShape

			$buffer[12] = `create3DFluid 20 20 20 10 10 10`;

			// MAYA 5.0 COMPATIBILITY ( THE NEXT TWO LINES ARE NOT NEEDED FOR MAYA 6+ )
			//
			$temp = `ls -sl`;
			$buffer[12] = $temp[0];

			// manage fluidShape attributes

			setAttr ( $buffer[12] + ".densityMethod" ) 3;
			setAttr ( $buffer[12] + ".densityGradient" ) 11;
			setAttr ( $buffer[12] + ".velocityMethod" ) 0;
			setAttr ( $buffer[12] + ".boundaryDraw" ) 4;
			setAttr ( $buffer[12] + ".wireframeDisplay" ) 0;
			setAttr ( $buffer[12] + ".dropoffShape" ) 1;
			setAttr ( $buffer[12] + ".edgeDropoff" ) 0.35;
			setAttr ( $buffer[12] + ".quality" ) 1;
			setAttr ( $buffer[12] + ".renderInterpolator" ) 3;
			setAttr ( $buffer[12] + ".colorTexture" ) 1;
			setAttr ( $buffer[12] + ".incandTexture" ) 1;
			setAttr ( $buffer[12] + ".opacityTexture" ) 1;
			setAttr ( $buffer[12] + ".textureType" ) 4;
			setAttr ( $buffer[12] + ".colorTexGain" ) 0.175;
			setAttr ( $buffer[12] + ".incandTexGain" ) 1.049;
			setAttr ( $buffer[12] + ".opacityTexGain" ) 0.547;
			setAttr ( $buffer[12] + ".color[0].color_Color" ) 0 0 0;
			setAttr ( $buffer[12] + ".colorInput" ) 4;
			setAttr ( $buffer[12] + ".incandescence[0].incandescence_Position" ) 0.029;
			setAttr ( $buffer[12] + ".incandescence[0].incandescence_Color" ) 0.15 0.15 0.15;
			setAttr ( $buffer[12] + ".incandescence[1].incandescence_Position" ) 0.193;
			setAttr ( $buffer[12] + ".incandescence[1].incandescence_Color" ) 0.425 0.056145 0.0221;
			setAttr ( $buffer[12] + ".incandescence[1].incandescence_Interp" ) 3;
			setAttr ( $buffer[12] + ".incandescence[2].incandescence_Position" ) 0.471;
			setAttr ( $buffer[12] + ".incandescence[2].incandescence_Color" ) 0.784 0.1279 0.046256;
			setAttr ( $buffer[12] + ".incandescence[2].incandescence_Interp" ) 2;
			setAttr ( $buffer[12] + ".incandescence[3].incandescence_Position" ) 0.664;
			setAttr ( $buffer[12] + ".incandescence[3].incandescence_Color" ) 1.747 0.361157 0.092591;
			setAttr ( $buffer[12] + ".incandescence[3].incandescence_Interp" ) 3;
			setAttr ( $buffer[12] + ".incandescence[4].incandescence_Color" ) 4 1.012111 0.276;
			setAttr ( $buffer[12] + ".incandescence[4].incandescence_Position" ) 1;
			setAttr ( $buffer[12] + ".incandescence[4].incandescence_Interp" ) 2;
			setAttr ( $buffer[12] + ".incandescenceInput" ) 4;
			setAttr ( $buffer[12] + ".opacity[0].opacity_Position" ) 0.164;
			setAttr ( $buffer[12] + ".opacity[1].opacity_FloatValue" ) 0.003;
			setAttr ( $buffer[12] + ".opacity[1].opacity_Position" ) 0.293;
			setAttr ( $buffer[12] + ".opacity[1].opacity_Interp" ) 1;
			setAttr ( $buffer[12] + ".opacity[2].opacity_FloatValue" ) 0.34;
			setAttr ( $buffer[12] + ".opacity[2].opacity_Position" ) 0.343;
			setAttr ( $buffer[12] + ".opacity[2].opacity_Interp" ) 1;
			setAttr ( $buffer[12] + ".opacity[3].opacity_FloatValue" ) 0.64;
			setAttr ( $buffer[12] + ".opacity[3].opacity_Position" ) 0.464;
			setAttr ( $buffer[12] + ".opacity[3].opacity_Interp" ) 1;
			setAttr ( $buffer[12] + ".opacity[4].opacity_FloatValue" ) 0.78;
			setAttr ( $buffer[12] + ".opacity[4].opacity_Position" ) 0.693;
			setAttr ( $buffer[12] + ".opacity[4].opacity_Interp" ) 1;
			setAttr ( $buffer[12] + ".ratio" ) 0.524;
			setAttr ( $buffer[12] + ".frequencyRatio" ) 1.961;
			setAttr ( $buffer[12] + ".depthMax" ) 4;
			setAttr ( $buffer[12] + ".inflection" ) 1;
			setAttr ( $buffer[12] + ".frequency" ) 2.184;
			setAttr ( $buffer[12] + ".textureScaleX" ) 5.5;
			setAttr ( $buffer[12] + ".textureScaleY" ) 5.5;
			setAttr ( $buffer[12] + ".textureScaleZ" ) 5.5;
			setAttr ( $buffer[12] + ".realLights" ) 0;
			setAttr ( $buffer[12] + ".castsShadows" ) 0;
			setAttr ( $buffer[12] + ".receiveShadows" ) 0;
			setAttr ( $buffer[12] + ".primaryVisibility" ) 0;
			setAttr ( $buffer[12] + ".visibleInReflections" ) 0;
			setAttr ( $buffer[12] + ".visibleInRefractions" ) 0;

			// assign fluidShape to trailsParticleShape

			$temp = `listConnections -s 0 -d 1 ( $buffer[12] + ".outColor" )`;
			select $buffer[2];
			sets -e -forceElement $temp[0];

			// create particleSamplerInfo

			$buffer[13] = `shadingNode -asUtility particleSamplerInfo`;

			// create arrayMapper for radiusMultPP

			$temp = `arrayMapper -target $buffer[2] -destAttr radiusMultPP -inputV ageNormalized -type ramp`;
			$buffer[3] = $temp[0];

			// create ramp for radiusMultPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[3] + ".computeNodeColor" )`;
			$buffer[4] = $temp[0];

			setAttr ( $buffer[4] + ".colorEntryList[0].color" ) 0.5 0.5 0.5;
			removeMultiInstance -break true ( $buffer[4] + ".colorEntryList[1]" );
			setAttr ( $buffer[4] + ".colorEntryList[2].color" ) 1 1 1;
			setAttr ( $buffer[4] + ".colorEntryList[2].position" ) 1;

			// create arrayMapper for radiusStartPP

			$temp = `arrayMapper -target $buffer[2] -destAttr radiusStartPP -inputV ageNormalized -type ramp`;
			$buffer[5] = $temp[0];

			// create ramp for radiusStartPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[5] + ".computeNodeColor" )`;
			$buffer[6] = $temp[0];

			setAttr ( $buffer[6] + ".colorEntryList[0].color" ) 0.9 0.9 0.9;
			removeMultiInstance -break true ( $buffer[6] + ".colorEntryList[1]" );
			setAttr ( $buffer[6] + ".colorEntryList[2].color" ) 1 1 1;
			setAttr ( $buffer[6] + ".colorEntryList[2].position" ) 1;
			setAttr ( $buffer[6] + ".noise" ) 1;

			// create arrayMapper for radiusMinPP

			$temp = `arrayMapper -target $buffer[2] -destAttr radiusMinPP -inputV birthTime -type ramp`;
			$buffer[28] = $temp[0];

			// create ramp for radiusMinPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[28] + ".computeNodeColor" )`;
			$buffer[29] = $temp[0];

			setAttr ( $buffer[29] + ".colorEntryList[0].color" ) 1 1 1;
			removeMultiInstance -break true ( $buffer[29] + ".colorEntryList[1]" );
			removeMultiInstance -break true ( $buffer[29] + ".colorEntryList[2]" );
			setAttr ( $buffer[29] + ".noise" ) 1;

			// create arrayMapper for radiusMaxPP

			$temp = `arrayMapper -target $buffer[2] -destAttr radiusMaxPP -inputV birthTime -type ramp`;
			$buffer[30] = $temp[0];

			// create ramp for radiusMaxPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[30] + ".computeNodeColor" )`;
			$buffer[31] = $temp[0];

			setAttr ( $buffer[31] + ".colorEntryList[0].color" ) 1 1 1;
			removeMultiInstance -break true ( $buffer[31] + ".colorEntryList[1]" );
			removeMultiInstance -break true ( $buffer[31] + ".colorEntryList[2]" );
			setAttr ( $buffer[31] + ".noise" ) 1;

			// create arrayMapper for opacityPP

			$temp = `arrayMapper -target $buffer[2] -destAttr opacityPP -inputV ageNormalized -type ramp`;
			$buffer[7] = $temp[0];

			// create ramp for opacityPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[7] + ".computeNodeColor" )`;
			$buffer[8] = $temp[0];

			setAttr ( $buffer[8] + ".colorEntryList[0].color" ) 0 0 0;
			removeMultiInstance -break true ( $buffer[8] + ".colorEntryList[1]" );
			removeMultiInstance -break true ( $buffer[8] + ".colorEntryList[2]" );

			// create connections between particleSamplerInfo and opacityPP

			connectAttr -f ( $buffer[13] + ".opacityPP" ) ( $buffer[12] + ".transparencyR" );
			connectAttr -f ( $buffer[13] + ".opacityPP" ) ( $buffer[12] + ".transparencyG" );
			connectAttr -f ( $buffer[13] + ".opacityPP" ) ( $buffer[12] + ".transparencyB" );

			// create arrayMapper for textureOriginPP

			$temp = `arrayMapper -target $buffer[2] -destAttr textureOriginPP -inputV ageNormalized -type ramp`;
			$buffer[14] = $temp[0];

			connectAttr -f ( $buffer[2] + ".textureOriginMin" ) ( $buffer[14] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".textureOriginMax" ) ( $buffer[14] + ".maxValue" );

			// create ramp for textureOriginPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[14] + ".computeNodeColor" )`;
			$buffer[15] = $temp[0];

			setAttr ( $buffer[15] + ".colorEntryList[0].color" ) 1 1 1;
			removeMultiInstance -break true ( $buffer[15] + ".colorEntryList[1]" );
			setAttr ( $buffer[15] + ".colorEntryList[2].color" ) 0 0 0;
			setAttr ( $buffer[15] + ".colorEntryList[2].position" ) 1;
			setAttr ( $buffer[15] + ".noise" ) 1;

			// create connections between particleSamplerInfo and textureOriginPP

			connectAttr -f ( $buffer[13] + ".userVector3PPX" ) ( $buffer[12] + ".textureOriginX" );
			connectAttr -f ( $buffer[13] + ".userVector3PPX" ) ( $buffer[12] + ".textureOriginY" );
			connectAttr -f ( $buffer[13] + ".userVector3PPX" ) ( $buffer[12] + ".textureOriginZ" );

			// create arrayMapper for textureScalePP

			$temp = `arrayMapper -target $buffer[2] -destAttr textureScalePP -inputV ageNormalized -type ramp`;
			$buffer[16] = $temp[0];

			connectAttr -f ( $buffer[2] + ".textureScaleMin" ) ( $buffer[16] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".textureScaleMax" ) ( $buffer[16] + ".maxValue" );

			// create ramp for textureScalePP

			$temp = `listConnections -s 1 -d 0 ( $buffer[16] + ".computeNodeColor" )`;
			$buffer[17] = $temp[0];

			setAttr ( $buffer[17] + ".colorEntryList[0].color" ) 1 1 1;
			removeMultiInstance -break true ( $buffer[17] + ".colorEntryList[1]" );
			setAttr ( $buffer[17] + ".colorEntryList[2].color" ) 0.5 0.5 0.5;
			setAttr ( $buffer[17] + ".colorEntryList[2].position" ) 1;

			// create connections between particleSamplerInfo and textureScalePP

			connectAttr -f ( $buffer[13] + ".userVector2PPZ" ) ( $buffer[12] + ".textureScaleX" );
			connectAttr -f ( $buffer[13] + ".userVector2PPZ" ) ( $buffer[12] + ".textureScaleY" );
			connectAttr -f ( $buffer[13] + ".userVector2PPZ" ) ( $buffer[12] + ".textureScaleZ" );

			// create arrayMapper for incandescenceInputBiasPP

			$temp = `arrayMapper -target $buffer[2] -destAttr incandescenceInputBiasPP -inputV ageNormalized -type ramp`;
			$buffer[18] = $temp[0];

			connectAttr -f ( $buffer[2] + ".incandescenceInputBiasMin" ) ( $buffer[18] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".incandescenceInputBiasMax" ) ( $buffer[18] + ".maxValue" );

			// create ramp for incandescenceInputBiasPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[18] + ".computeNodeColor" )`;
			$buffer[19] = $temp[0];

			setAttr ( $buffer[19] + ".interpolation" ) 3;
			setAttr ( $buffer[19] + ".colorEntryList[0].color" ) 0.85 0.85 0.85;
			setAttr ( $buffer[19] + ".colorEntryList[0].position" ) 0;
			setAttr ( $buffer[19] + ".colorEntryList[1].color" ) 0.5 0.5 0.5;
			setAttr ( $buffer[19] + ".colorEntryList[1].position" ) 0.01;
			setAttr ( $buffer[19] + ".colorEntryList[2].color" ) 0.175 0.175 0.175;
			setAttr ( $buffer[19] + ".colorEntryList[2].position" ) 0.05;

			// create connections between particleSamplerInfo and incandescenceInputBiasPP

			connectAttr -f ( $buffer[13] + ".userVector1PPY" ) ( $buffer[12] + ".incandescenceInputBias" );

			// create arrayMapper for textureTimePP

			$temp = `arrayMapper -target $buffer[2] -destAttr textureTimePP -inputV ageNormalized -type ramp`;
			$buffer[20] = $temp[0];

			connectAttr -f ( $buffer[2] + ".textureTimeMin" ) ( $buffer[20] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".textureTimeMax" ) ( $buffer[20] + ".maxValue" );

			// create ramp for textureTimePP

			$temp = `listConnections -s 1 -d 0 ( $buffer[20] + ".computeNodeColor" )`;
			$buffer[21] = $temp[0];

			setAttr ( $buffer[21] + ".interpolation" ) 3;
			setAttr ( $buffer[21] + ".colorEntryList[0].color" ) 0 0 0;
			removeMultiInstance -break true ( $buffer[21] + ".colorEntryList[1]" );
			setAttr ( $buffer[21] + ".colorEntryList[2].color" ) 0.75 0.75 0.75;
			setAttr ( $buffer[21] + ".colorEntryList[2].position" ) 1;

			// create connections between particleSamplerInfo and textureTimePP

			connectAttr -f ( $buffer[13] + ".userVector2PPY" ) ( $buffer[12] + ".textureTime" );

			// create arrayMapper for amplitudePP

			$temp = `arrayMapper -target $buffer[2] -destAttr amplitudePP -inputV ageNormalized -type ramp`;
			$buffer[22] = $temp[0];

			connectAttr -f ( $buffer[2] + ".amplitudeMin" ) ( $buffer[22] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".amplitudeMax" ) ( $buffer[22] + ".maxValue" );

			// create ramp for amplitudePP

			$temp = `listConnections -s 1 -d 0 ( $buffer[22] + ".computeNodeColor" )`;
			$buffer[23] = $temp[0];

			setAttr ( $buffer[23] + ".colorEntryList[0].color" ) 0 0 0;
			removeMultiInstance -break true ( $buffer[23] + ".colorEntryList[1]" );
			setAttr ( $buffer[23] + ".colorEntryList[2].color" ) 1 1 1;
			setAttr ( $buffer[23] + ".colorEntryList[2].position" ) 1;

			// create connections between particleSamplerInfo and amplitudePP

			connectAttr -f ( $buffer[13] + ".userVector2PPX" ) ( $buffer[12] + ".amplitude" );

			// create arrayMapper for colorInputBiasPP

			$temp = `arrayMapper -target $buffer[2] -destAttr colorInputBiasPP -inputV ageNormalized -type ramp`;
			$buffer[24] = $temp[0];

			connectAttr -f ( $buffer[2] + ".colorInputBiasMin" ) ( $buffer[24] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".colorInputBiasMax" ) ( $buffer[24] + ".maxValue" );

			// create ramp for colorInputBiasPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[24] + ".computeNodeColor" )`;
			$buffer[25] = $temp[0];

			setAttr ( $buffer[25] + ".colorEntryList[0].color" ) 0 0 0;
			removeMultiInstance -break true ( $buffer[25] + ".colorEntryList[1]" );
			removeMultiInstance -break true ( $buffer[25] + ".colorEntryList[2]" );

			// create connections between particleSamplerInfo and colorInputBiasPP

			connectAttr -f ( $buffer[13] + ".userVector1PPX" ) ( $buffer[12] + ".colorInputBias" );

			// create arrayMapper for opacityInputBiasPP

			$temp = `arrayMapper -target $buffer[2] -destAttr opacityInputBiasPP -inputV ageNormalized -type ramp`;
			$buffer[26] = $temp[0];

			connectAttr -f ( $buffer[2] + ".opacityInputBiasMin" ) ( $buffer[26] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".opacityInputBiasMax" ) ( $buffer[26] + ".maxValue" );

			// create ramp for opacityInputBiasPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[26] + ".computeNodeColor" )`;
			$buffer[27] = $temp[0];

			setAttr ( $buffer[27] + ".colorEntryList[0].color" ) 0 0 0;
			removeMultiInstance -break true ( $buffer[27] + ".colorEntryList[1]" );
			removeMultiInstance -break true ( $buffer[27] + ".colorEntryList[2]" );

			// create connections between particleSamplerInfo and opacityInputBiasPP

			connectAttr -f ( $buffer[13] + ".userVector1PPZ" ) ( $buffer[12] + ".opacityInputBias" );

			// set expressions

			$explression = "radiusPP = clamp ( radiusMin * radiusMinPP, radiusMax * radiusMaxPP, 0.1 * radius * radiusStartPP );\n";
			$explression += "userVector3PP = << textureOriginPP, 0, 0 >>;";

			dynExpression -s $explression -c $buffer[2];

			$explression = "velocity += sphrand ( velocityRand );\n";
			$explression += "radiusPP = clamp ( radiusMin * radiusMinPP, radiusMax * radiusMaxPP, radiusPP + 0.01 * radiusMultPP * radiusMult );\n";
			$explression += "userVector1PP = << colorInputBiasPP, incandescenceInputBiasPP, opacityInputBiasPP >>;\n";
			$explression += "userVector2PP = << amplitudePP, textureTimePP, textureScalePP >>;";

			string $ver = `about -v`;

			if ( int ( substring ( $ver, 1, 1 ) ) > 5 )
			{
				dynExpression -s $explression -rbd $buffer[2];
			}
			else
			{
				dynExpression -s $explression -r $buffer[2];
			}

			string $groupName = `group -n "tendrils_small#" $buffer[0] $buffer[1] $buffer[9] $buffer[12]`;
			string $tok[];
			tokenize $groupName "l" $tok;

			// rename nodes

			rename $buffer[0] ( "tendSmall" + $tok[2] + "_leadEmitter" );
			rename $buffer[1] ( "tendSmall" + $tok[2] + "_trailParticle" );
			rename $buffer[3] ( "tendSmall" + $tok[2] + "_radMultPP_aMapper" );
			rename $buffer[4] ( "tendSmall" + $tok[2] + "_radMultPP_ramp" );
			rename $buffer[5] ( "tendSmall" + $tok[2] + "_radStartPP_aMapper" );
			rename $buffer[6] ( "tendSmall" + $tok[2] + "_radStartPP_ramp" );
			rename $buffer[7] ( "tendSmall" + $tok[2] + "_opacPP_aMapper" );
			rename $buffer[8] ( "tendSmall" + $tok[2] + "_opacPP_ramp" );
			rename $buffer[9] ( "tendSmall" + $tok[2] + "_leadParticle" );
			rename $buffer[10] ( "tendSmall" + $tok[2] + "_trailEmitter" );
			rename $buffer[12] ( "tendSmall" + $tok[2] + "_fluid" );
			rename $buffer[14] ( "tendSmall" + $tok[2] + "_texOrigPP_aMapper" );
			rename $buffer[15] ( "tendSmall" + $tok[2] + "_texOrigPP_ramp" );
			rename $buffer[16] ( "tendSmall" + $tok[2] + "_texScalePP_aMapper" );
			rename $buffer[17] ( "tendSmall" + $tok[2] + "_texScalePP_ramp" );
			rename $buffer[18] ( "tendSmall" + $tok[2] + "_incanInBiasPP_aMapper" );
			rename $buffer[19] ( "tendSmall" + $tok[2] + "_incanInBiasPP_ramp" );
			rename $buffer[20] ( "tendSmall" + $tok[2] + "_texTimePP_aMapper" );
			rename $buffer[21] ( "tendSmall" + $tok[2] + "_texTimePP_ramp" );
			rename $buffer[22] ( "tendSmall" + $tok[2] + "_ampPP_aMapper" );
			rename $buffer[23] ( "tendSmall" + $tok[2] + "_ampPP_ramp" );
			rename $buffer[24] ( "tendSmall" + $tok[2] + "_colorInBiasPP_aMapper" );
			rename $buffer[25] ( "tendSmall" + $tok[2] + "_colorInBiasPP_ramp" );
			rename $buffer[26] ( "tendSmall" + $tok[2] + "_opacInBiasPP_aMapper" );
			rename $buffer[27] ( "tendSmall" + $tok[2] + "_opacInBiasPP_ramp" );
			rename $buffer[28] ( "tendSmall" + $tok[2] + "_radMinPP_aMapper" );
			rename $buffer[29] ( "tendSmall" + $tok[2] + "_radMinPP_ramp" );
			rename $buffer[30] ( "tendSmall" + $tok[2] + "_radMaxPP_aMapper" );
			rename $buffer[31] ( "tendSmall" + $tok[2] + "_radMaxPP_ramp" );

			break;

		// #################################################################################################
		// #    CREATE FIREBALLS								   	   						    #
		// #################################################################################################

		case "fireBalls":
			string $buffer[], $temp[], $explression;

			// create emitter

			$temp = `emitter -pos 0 0 0 -type omni -r 100 -sro 0 -nuv 0 -cye none -cyi 1 -spd 1 -srn 0 -nsp 1 -tsp 0 -mxd 0 -mnd 0 -dx 1 -dy 0 -dz 0 -sp 0`;
			$buffer[0] = $temp[0];

			// set emission attributes

			setAttr ( $buffer[0] + ".rate" ) 5;
			setAttr ( $buffer[0] + ".speedRandom" ) 3;
			setAttr ( $buffer[0] + ".awayFromCenter" ) 1;
			setAttr ( $buffer[0] + ".randomDirection" ) 1;
			setAttr ( $buffer[0] + ".directionalSpeed" ) 1;
			setAttr ( $buffer[0] + ".emitterType" ) 4;
			setAttr ( $buffer[0] + ".volumeShape" ) 1;
			setAttr ( $buffer[0] + ".directionX" ) 0;

			$temp = `particle`;
			$buffer[9] = $temp[0];
			$buffer[11] = $temp[1];

			// connect leadParticleShape to emitter

			connectDynamic -em $buffer[0] $buffer[9];

			// manage leadParticleShape attributes

			setAttr ( $buffer[11] + ".conserve" ) 0.995;
			setAttr ( $buffer[11] + ".particleRenderType" ) 2;
			addAttr -ln velocityRand -at double -smn 0 -smx 2 -dv 0.1 $buffer[11];

			string $ver = `about -v`;

			if ( int ( substring ( $ver, 1, 1 ) ) > 5 )
			{
				dynExpression -s "velocity = velocity + sphrand ( velocityRand )" -rbd $buffer[11];
			}
			else
			{
				dynExpression -s "velocity = velocity + sphrand ( velocityRand )" -r $buffer[11];
			}

			// create leadParticleShape emitter

			select $buffer[9];
			$temp = `emitter -type omni -r 100 -sro 0 -nuv 0 -cye none -cyi 1 -spd 1 -srn 0 -nsp 1 -tsp 0 -mxd 0 -mnd 0 -dx 1 -dy 0 -dz 0 -sp 0`;
			$buffer[10] = $temp[1];

			// set leadParticleShape emitter attribtues

			setAttr ( $buffer[10] + ".rate" ) 20;
			setAttr ( $buffer[10] + ".speed" ) 0;

			// create trailsParticleShape

			$temp = `particle`;
			$buffer[1] = $temp[0];
			$buffer[2] = $temp[1];

			// connect trailsParticleShape to leadParticleShape emitter

			connectDynamic -em $buffer[10] $buffer[2];

			// manage trailsParticleShape attributes

			setAttr ( $buffer[2] + ".conserve" ) 0.995;
			setAttr ( $buffer[2] + ".lifespanMode" ) 2;
			setAttr ( $buffer[2] + ".lifespan" ) 10;
			setAttr ( $buffer[2] + ".lifespanRandom" ) 1;
			setAttr ( $buffer[2] + ".particleRenderType" ) 8;
			addAttr -is true -ln "betterIllumination" -at bool -dv false $buffer[2];
			addAttr -is true -ln "surfaceShading" -at "float" -smn 0 -smx 1 -dv 0 $buffer[2];
			addAttr -is true -ln "threshold" -at "float" -smn 0 -smx 10 -dv 0 $buffer[2];
			addAttr -is true -ln "radius" -at "float" -smn 0 -smx 20 -dv 2 $buffer[2];
			addAttr -ln radiusPP -dt doubleArray $buffer[2];
			addAttr -ln radiusMultPP -dt doubleArray $buffer[2];
			addAttr -ln radiusStartPP -dt doubleArray $buffer[2];
			addAttr -ln radiusMinPP -dt doubleArray $buffer[2];
			addAttr -ln radiusMaxPP -dt doubleArray $buffer[2];
			addAttr -ln opacityPP -dt doubleArray $buffer[2];
			addAttr -ln colorInputBiasPP -dt doubleArray $buffer[2];
			addAttr -ln incandescenceInputBiasPP -dt doubleArray $buffer[2];
			addAttr -ln opacityInputBiasPP -dt doubleArray $buffer[2];
			addAttr -ln amplitudePP -dt doubleArray $buffer[2];
			addAttr -ln textureTimePP -dt doubleArray $buffer[2];
			addAttr -ln textureScalePP -dt doubleArray $buffer[2];
			addAttr -ln textureOriginPP -dt doubleArray $buffer[2];
			addAttr -ln userVector1PP -dt vectorArray $buffer[2];
			addAttr -ln userVector2PP -dt vectorArray $buffer[2];
			addAttr -ln userVector3PP -dt vectorArray $buffer[2];
			addAttr -ln velocityRand -at double -smn 0 -smx 2 -dv 0.05 $buffer[2];
			addAttr -ln radiusMult -at double -smn 0 -smx 20 -dv 1.5 $buffer[2];
			addAttr -ln radiusMin -at double -smn 0 -smx 20 -dv 0 $buffer[2];
			addAttr -ln radiusMax -at double -smn 0 -smx 20 -dv 2 $buffer[2];
			addAttr -ln colorInputBiasMin -at double -smn -1 -smx 1 -dv 0 $buffer[2];
			addAttr -ln colorInputBiasMax -at double -smn -1 -smx 1 -dv 0 $buffer[2];
			addAttr -ln incandescenceInputBiasMin -at double -smn -1 -smx 1 -dv -1 $buffer[2];
			addAttr -ln incandescenceInputBiasMax -at double -smn -1 -smx 1 -dv 1 $buffer[2];
			addAttr -ln opacityInputBiasMin -at double -smn -1 -smx 1 -dv 0 $buffer[2];
			addAttr -ln opacityInputBiasMax -at double -smn -1 -smx 1 -dv 0 $buffer[2];
			addAttr -ln amplitudeMin -at double -smn 0 -smx 1 -dv 0.4 $buffer[2];
			addAttr -ln amplitudeMax -at double -smn 0 -smx 3 -dv 2.5 $buffer[2];
			addAttr -ln textureTimeMin -at double -smn 0 -smx 1 -dv 0 $buffer[2];
			addAttr -ln textureTimeMax -at double -smn 0 -smx 1 -dv 1 $buffer[2];
			addAttr -ln textureScaleMin -at double -smn 0 -smx 10 -dv 0 $buffer[2];
			addAttr -ln textureScaleMax -at double -smn 0 -smx 10 -dv 1.5 $buffer[2];
			addAttr -ln textureOriginMin -at double -smn 0 -smx 2 -dv 0 $buffer[2];
			addAttr -ln textureOriginMax -at double -smn 0 -smx 2 -dv 1 $buffer[2];

			// create fluidShape

			$buffer[12] = `create3DFluid 20 20 20 10 10 10`;

			// MAYA 5.0 COMPATIBILITY ( THE NEXT TWO LINES ARE NOT NEEDED FOR MAYA 6+ )
			//
			$temp = `ls -sl`;
			$buffer[12] = $temp[0];

			// manage fluidShape attributes

			setAttr ( $buffer[12] + ".densityMethod" ) 3;
			setAttr ( $buffer[12] + ".densityGradient" ) 11;
			setAttr ( $buffer[12] + ".velocityMethod" ) 0;
			setAttr ( $buffer[12] + ".boundaryDraw" ) 4;
			setAttr ( $buffer[12] + ".wireframeDisplay" ) 0;
			setAttr ( $buffer[12] + ".dropoffShape" ) 1;
			setAttr ( $buffer[12] + ".edgeDropoff" ) 0.35;
			setAttr ( $buffer[12] + ".quality" ) 0.5;
			setAttr ( $buffer[12] + ".renderInterpolator" ) 3;
			setAttr ( $buffer[12] + ".colorTexture" ) 1;
			setAttr ( $buffer[12] + ".incandTexture" ) 1;
			setAttr ( $buffer[12] + ".opacityTexture" ) 1;
			setAttr ( $buffer[12] + ".textureType" ) 4;
			setAttr ( $buffer[12] + ".colorTexGain" ) 0.175;
			setAttr ( $buffer[12] + ".incandTexGain" ) 1.049;
			setAttr ( $buffer[12] + ".opacityTexGain" ) 0.547;
			setAttr ( $buffer[12] + ".color[0].color_Color" ) 0 0 0;
			setAttr ( $buffer[12] + ".colorInput" ) 4;
			setAttr ( $buffer[12] + ".incandescence[0].incandescence_Position" ) 0.029;
			setAttr ( $buffer[12] + ".incandescence[0].incandescence_Color" ) 0 0 0;
			setAttr ( $buffer[12] + ".incandescence[1].incandescence_Position" ) 0.193;
			setAttr ( $buffer[12] + ".incandescence[1].incandescence_Color" ) 0.425 0.056145 0.0221;
			setAttr ( $buffer[12] + ".incandescence[1].incandescence_Interp" ) 3;
			setAttr ( $buffer[12] + ".incandescence[2].incandescence_Position" ) 0.471;
			setAttr ( $buffer[12] + ".incandescence[2].incandescence_Color" ) 0.784 0.1279 0.046256;
			setAttr ( $buffer[12] + ".incandescence[2].incandescence_Interp" ) 2;
			setAttr ( $buffer[12] + ".incandescence[3].incandescence_Position" ) 0.664;
			setAttr ( $buffer[12] + ".incandescence[3].incandescence_Color" ) 1.747 0.361157 0.092591;
			setAttr ( $buffer[12] + ".incandescence[3].incandescence_Interp" ) 3;
			setAttr ( $buffer[12] + ".incandescence[4].incandescence_Color" ) 4 1.012111 0.276;
			setAttr ( $buffer[12] + ".incandescence[4].incandescence_Position" ) 1;
			setAttr ( $buffer[12] + ".incandescence[4].incandescence_Interp" ) 2;
			setAttr ( $buffer[12] + ".incandescenceInput" ) 4;
			setAttr ( $buffer[12] + ".opacity[0].opacity_Position" ) 0.164;
			setAttr ( $buffer[12] + ".opacity[1].opacity_FloatValue" ) 0.003;
			setAttr ( $buffer[12] + ".opacity[1].opacity_Position" ) 0.293;
			setAttr ( $buffer[12] + ".opacity[1].opacity_Interp" ) 1;
			setAttr ( $buffer[12] + ".opacity[2].opacity_FloatValue" ) 0.340;
			setAttr ( $buffer[12] + ".opacity[2].opacity_Position" ) 0.343;
			setAttr ( $buffer[12] + ".opacity[2].opacity_Interp" ) 1;
			setAttr ( $buffer[12] + ".opacity[3].opacity_FloatValue" ) 0.640;
			setAttr ( $buffer[12] + ".opacity[3].opacity_Position" ) 0.464;
			setAttr ( $buffer[12] + ".opacity[3].opacity_Interp" ) 1;
			setAttr ( $buffer[12] + ".opacity[4].opacity_FloatValue" ) 0.780;
			setAttr ( $buffer[12] + ".opacity[4].opacity_Position" ) 0.693;
			setAttr ( $buffer[12] + ".opacity[4].opacity_Interp" ) 1;
			setAttr ( $buffer[12] + ".ratio" ) 0.524;
			setAttr ( $buffer[12] + ".frequencyRatio" ) 1.961;
			setAttr ( $buffer[12] + ".depthMax" ) 4;
			setAttr ( $buffer[12] + ".inflection" ) 1;
			setAttr ( $buffer[12] + ".frequency" ) 2.184;
			setAttr ( $buffer[12] + ".textureScaleX" ) 5.5;
			setAttr ( $buffer[12] + ".textureScaleY" ) 5.5;
			setAttr ( $buffer[12] + ".textureScaleZ" ) 5.5;
			setAttr ( $buffer[12] + ".realLights" ) 0;
			setAttr ( $buffer[12] + ".castsShadows" ) 0;
			setAttr ( $buffer[12] + ".receiveShadows" ) 0;
			setAttr ( $buffer[12] + ".primaryVisibility" ) 0;
			setAttr ( $buffer[12] + ".visibleInReflections" ) 0;
			setAttr ( $buffer[12] + ".visibleInRefractions" ) 0;

			// assign fluidShape to trailsParticleShape

			$temp = `listConnections -s 0 -d 1 ( $buffer[12] + ".outColor" )`;
			select $buffer[2];
			sets -e -forceElement $temp[0];

			// create particleSamplerInfo

			$buffer[13] = `shadingNode -asUtility particleSamplerInfo`;

			// create arrayMapper for radiusMultPP

			$temp = `arrayMapper -target $buffer[2] -destAttr radiusMultPP -inputV ageNormalized -type ramp`;
			$buffer[3] = $temp[0];

			// create ramp for radiusMultPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[3] + ".computeNodeColor" )`;
			$buffer[4] = $temp[0];

			setAttr ( $buffer[4] + ".colorEntryList[0].color" ) 0.5 0.5 0.5;
			removeMultiInstance -break true ( $buffer[4] + ".colorEntryList[1]" );
			setAttr ( $buffer[4] + ".colorEntryList[2].color" ) 1 1 1;
			setAttr ( $buffer[4] + ".colorEntryList[2].position" ) 1;

			// create arrayMapper for radiusStartPP

			$temp = `arrayMapper -target $buffer[2] -destAttr radiusStartPP -inputV ageNormalized -type ramp`;
			$buffer[5] = $temp[0];

			// create ramp for radiusStartPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[5] + ".computeNodeColor" )`;
			$buffer[6] = $temp[0];

			setAttr ( $buffer[6] + ".colorEntryList[0].color" ) 0.9 0.9 0.9;
			removeMultiInstance -break true ( $buffer[6] + ".colorEntryList[1]" );
			setAttr ( $buffer[6] + ".colorEntryList[2].color" ) 1 1 1;
			setAttr ( $buffer[6] + ".colorEntryList[2].position" ) 1;
			setAttr ( $buffer[6] + ".noise" ) 1;

			// create arrayMapper for radiusMinPP

			$temp = `arrayMapper -target $buffer[2] -destAttr radiusMinPP -inputV birthTime -type ramp`;
			$buffer[28] = $temp[0];

			// create ramp for radiusMinPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[28] + ".computeNodeColor" )`;
			$buffer[29] = $temp[0];

			setAttr ( $buffer[29] + ".colorEntryList[0].color" ) 1 1 1;
			removeMultiInstance -break true ( $buffer[29] + ".colorEntryList[1]" );
			removeMultiInstance -break true ( $buffer[29] + ".colorEntryList[2]" );
			setAttr ( $buffer[29] + ".noise" ) 1;

			// create arrayMapper for radiusMaxPP

			$temp = `arrayMapper -target $buffer[2] -destAttr radiusMaxPP -inputV birthTime -type ramp`;
			$buffer[30] = $temp[0];

			// create ramp for radiusMaxPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[30] + ".computeNodeColor" )`;
			$buffer[31] = $temp[0];

			setAttr ( $buffer[31] + ".colorEntryList[0].color" ) 1 1 1;
			removeMultiInstance -break true ( $buffer[31] + ".colorEntryList[1]" );
			removeMultiInstance -break true ( $buffer[31] + ".colorEntryList[2]" );
			setAttr ( $buffer[31] + ".noise" ) 1;

			// create arrayMapper for opacityPP

			$temp = `arrayMapper -target $buffer[2] -destAttr opacityPP -inputV ageNormalized -type ramp`;
			$buffer[7] = $temp[0];

			// create ramp for opacityPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[7] + ".computeNodeColor" )`;
			$buffer[8] = $temp[0];

			setAttr ( $buffer[8] + ".colorEntryList[0].color" ) 0 0 0;
			removeMultiInstance -break true ( $buffer[8] + ".colorEntryList[1]" );
			removeMultiInstance -break true ( $buffer[8] + ".colorEntryList[2]" );

			// create connections between particleSamplerInfo and opacityPP

			connectAttr -f ( $buffer[13] + ".opacityPP" ) ( $buffer[12] + ".transparencyR" );
			connectAttr -f ( $buffer[13] + ".opacityPP" ) ( $buffer[12] + ".transparencyG" );
			connectAttr -f ( $buffer[13] + ".opacityPP" ) ( $buffer[12] + ".transparencyB" );

			// create arrayMapper for textureOriginPP

			$temp = `arrayMapper -target $buffer[2] -destAttr textureOriginPP -inputV ageNormalized -type ramp`;
			$buffer[14] = $temp[0];

			connectAttr -f ( $buffer[2] + ".textureOriginMin" ) ( $buffer[14] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".textureOriginMax" ) ( $buffer[14] + ".maxValue" );

			// create ramp for textureOriginPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[14] + ".computeNodeColor" )`;
			$buffer[15] = $temp[0];

			setAttr ( $buffer[15] + ".colorEntryList[0].color" ) 1 1 1;
			removeMultiInstance -break true ( $buffer[15] + ".colorEntryList[1]" );
			setAttr ( $buffer[15] + ".colorEntryList[2].color" ) 0 0 0;
			setAttr ( $buffer[15] + ".colorEntryList[2].position" ) 1;
			setAttr ( $buffer[15] + ".noise" ) 1;

			// create connections between particleSamplerInfo and textureOriginPP

			connectAttr -f ( $buffer[13] + ".userVector3PPX" ) ( $buffer[12] + ".textureOriginX" );
			connectAttr -f ( $buffer[13] + ".userVector3PPX" ) ( $buffer[12] + ".textureOriginY" );
			connectAttr -f ( $buffer[13] + ".userVector3PPX" ) ( $buffer[12] + ".textureOriginZ" );

			// create arrayMapper for textureScalePP

			$temp = `arrayMapper -target $buffer[2] -destAttr textureScalePP -inputV ageNormalized -type ramp`;
			$buffer[16] = $temp[0];

			connectAttr -f ( $buffer[2] + ".textureScaleMin" ) ( $buffer[16] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".textureScaleMax" ) ( $buffer[16] + ".maxValue" );

			// create ramp for textureScalePP

			$temp = `listConnections -s 1 -d 0 ( $buffer[16] + ".computeNodeColor" )`;
			$buffer[17] = $temp[0];

			setAttr ( $buffer[17] + ".colorEntryList[0].color" ) 1 1 1;
			removeMultiInstance -break true ( $buffer[17] + ".colorEntryList[1]" );
			setAttr ( $buffer[17] + ".colorEntryList[2].color" ) 0.5 0.5 0.5;
			setAttr ( $buffer[17] + ".colorEntryList[2].position" ) 1;

			// create connections between particleSamplerInfo and textureScalePP

			connectAttr -f ( $buffer[13] + ".userVector2PPZ" ) ( $buffer[12] + ".textureScaleX" );
			connectAttr -f ( $buffer[13] + ".userVector2PPZ" ) ( $buffer[12] + ".textureScaleY" );
			connectAttr -f ( $buffer[13] + ".userVector2PPZ" ) ( $buffer[12] + ".textureScaleZ" );

			// create arrayMapper for incandescenceInputBiasPP

			$temp = `arrayMapper -target $buffer[2] -destAttr incandescenceInputBiasPP -inputV ageNormalized -type ramp`;
			$buffer[18] = $temp[0];

			connectAttr -f ( $buffer[2] + ".incandescenceInputBiasMin" ) ( $buffer[18] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".incandescenceInputBiasMax" ) ( $buffer[18] + ".maxValue" );

			// create ramp for incandescenceInputBiasPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[18] + ".computeNodeColor" )`;
			$buffer[19] = $temp[0];

			setAttr ( $buffer[19] + ".interpolation" ) 3;
			setAttr ( $buffer[19] + ".colorEntryList[0].color" ) 0.85 0.85 0.85;
			setAttr ( $buffer[19] + ".colorEntryList[1].color" ) 0.5 0.5 0.5;
			setAttr ( $buffer[19] + ".colorEntryList[1].position" ) 0.1;
			setAttr ( $buffer[19] + ".colorEntryList[2].color" ) 0 0 0;
			setAttr ( $buffer[19] + ".colorEntryList[2].position" ) 1;

			// create connections between particleSamplerInfo and incandescenceInputBiasPP

			connectAttr -f ( $buffer[13] + ".userVector1PPY" ) ( $buffer[12] + ".incandescenceInputBias" );

			// create arrayMapper for textureTimePP

			$temp = `arrayMapper -target $buffer[2] -destAttr textureTimePP -inputV ageNormalized -type ramp`;
			$buffer[20] = $temp[0];

			connectAttr -f ( $buffer[2] + ".textureTimeMin" ) ( $buffer[20] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".textureTimeMax" ) ( $buffer[20] + ".maxValue" );

			// create ramp for textureTimePP

			$temp = `listConnections -s 1 -d 0 ( $buffer[20] + ".computeNodeColor" )`;
			$buffer[21] = $temp[0];

			setAttr ( $buffer[21] + ".interpolation" ) 3;
			setAttr ( $buffer[21] + ".colorEntryList[0].color" ) 0 0 0;
			removeMultiInstance -break true ( $buffer[21] + ".colorEntryList[1]" );
			setAttr ( $buffer[21] + ".colorEntryList[2].color" ) 0.75 0.75 0.75;
			setAttr ( $buffer[21] + ".colorEntryList[2].position" ) 1;

			// create connections between particleSamplerInfo and textureTimePP

			connectAttr -f ( $buffer[13] + ".userVector2PPY" ) ( $buffer[12] + ".textureTime" );

			// create arrayMapper for amplitudePP

			$temp = `arrayMapper -target $buffer[2] -destAttr amplitudePP -inputV ageNormalized -type ramp`;
			$buffer[22] = $temp[0];

			connectAttr -f ( $buffer[2] + ".amplitudeMin" ) ( $buffer[22] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".amplitudeMax" ) ( $buffer[22] + ".maxValue" );

			// create ramp for amplitudePP

			$temp = `listConnections -s 1 -d 0 ( $buffer[22] + ".computeNodeColor" )`;
			$buffer[23] = $temp[0];

			setAttr ( $buffer[23] + ".colorEntryList[0].color" ) 0 0 0;
			removeMultiInstance -break true ( $buffer[23] + ".colorEntryList[1]" );
			setAttr ( $buffer[23] + ".colorEntryList[2].color" ) 1 1 1;
			setAttr ( $buffer[23] + ".colorEntryList[2].position" ) 1;

			// create connections between particleSamplerInfo and amplitudePP

			connectAttr -f ( $buffer[13] + ".userVector2PPX" ) ( $buffer[12] + ".amplitude" );

			// create arrayMapper for colorInputBiasPP

			$temp = `arrayMapper -target $buffer[2] -destAttr colorInputBiasPP -inputV ageNormalized -type ramp`;
			$buffer[24] = $temp[0];

			connectAttr -f ( $buffer[2] + ".colorInputBiasMin" ) ( $buffer[24] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".colorInputBiasMax" ) ( $buffer[24] + ".maxValue" );

			// create ramp for colorInputBiasPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[24] + ".computeNodeColor" )`;
			$buffer[25] = $temp[0];

			setAttr ( $buffer[25] + ".colorEntryList[0].color" ) 0 0 0;
			removeMultiInstance -break true ( $buffer[25] + ".colorEntryList[1]" );
			removeMultiInstance -break true ( $buffer[25] + ".colorEntryList[2]" );

			// create connections between particleSamplerInfo and colorInputBiasPP

			connectAttr -f ( $buffer[13] + ".userVector1PPX" ) ( $buffer[12] + ".colorInputBias" );

			// create arrayMapper for opacityInputBiasPP

			$temp = `arrayMapper -target $buffer[2] -destAttr opacityInputBiasPP -inputV ageNormalized -type ramp`;
			$buffer[26] = $temp[0];

			connectAttr -f ( $buffer[2] + ".opacityInputBiasMin" ) ( $buffer[26] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".opacityInputBiasMax" ) ( $buffer[26] + ".maxValue" );

			// create ramp for opacityInputBiasPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[26] + ".computeNodeColor" )`;
			$buffer[27] = $temp[0];

			setAttr ( $buffer[27] + ".colorEntryList[0].color" ) 0 0 0;
			removeMultiInstance -break true ( $buffer[27] + ".colorEntryList[1]" );
			removeMultiInstance -break true ( $buffer[27] + ".colorEntryList[2]" );

			// create connections between particleSamplerInfo and opacityInputBiasPP

			connectAttr -f ( $buffer[13] + ".userVector1PPZ" ) ( $buffer[12] + ".opacityInputBias" );

			// set expressions

			$explression = "radiusPP = clamp ( radiusMin * radiusMinPP, radiusMax * radiusMaxPP, 0.1 * radius * radiusStartPP );\n";
			$explression += "userVector3PP = << textureOriginPP, 0, 0 >>;";

			dynExpression -s $explression -c $buffer[2];

			$explression = "velocity += sphrand ( velocityRand );\n";
			$explression += "radiusPP = clamp ( radiusMin * radiusMinPP, radiusMax * radiusMaxPP, radiusPP + 0.01 * radiusMultPP * radiusMult );\n";
			$explression += "userVector1PP = << colorInputBiasPP, incandescenceInputBiasPP, opacityInputBiasPP >>;\n";
			$explression += "userVector2PP = << amplitudePP, textureTimePP, textureScalePP >>;";

			string $ver = `about -v`;

			if ( int ( substring ( $ver, 1, 1 ) ) > 5 )
			{
				dynExpression -s $explression -rbd $buffer[2];
			}
			else
			{
				dynExpression -s $explression -r $buffer[2];
			}

			string $groupName = `group -n "tendrils_independent#" $buffer[0] $buffer[1] $buffer[9] $buffer[12]`;
			string $tok[];
			tokenize $groupName "t" $tok;

			// rename nodes

			rename $buffer[0] ( "tendInd" + $tok[1] + "_leadEmitter" );
			rename $buffer[1] ( "tendInd" + $tok[1] + "_trailParticle" );
			rename $buffer[3] ( "tendInd" + $tok[1] + "_radMultPP_aMapper" );
			rename $buffer[4] ( "tendInd" + $tok[1] + "_radMultPP_ramp" );
			rename $buffer[5] ( "tendInd" + $tok[1] + "_radStartPP_aMapper" );
			rename $buffer[6] ( "tendInd" + $tok[1] + "_radStartPP_ramp" );
			rename $buffer[7] ( "tendInd" + $tok[1] + "_opacPP_aMapper" );
			rename $buffer[8] ( "tendInd" + $tok[1] + "_opacPP_ramp" );
			rename $buffer[9] ( "tendInd" + $tok[1] + "_leadParticle" );
			rename $buffer[10] ( "tendInd" + $tok[1] + "_trailEmitter" );
			rename $buffer[12] ( "tendInd" + $tok[1] + "_fluid" );
			rename $buffer[14] ( "tendInd" + $tok[1] + "_texOrigPP_aMapper" );
			rename $buffer[15] ( "tendInd" + $tok[1] + "_texOrigPP_ramp" );
			rename $buffer[16] ( "tendInd" + $tok[1] + "_texScalePP_aMapper" );
			rename $buffer[17] ( "tendInd" + $tok[1] + "_texScalePP_ramp" );
			rename $buffer[18] ( "tendInd" + $tok[1] + "_incanInBiasPP_aMapper" );
			rename $buffer[19] ( "tendInd" + $tok[1] + "_incanInBiasPP_ramp" );
			rename $buffer[20] ( "tendInd" + $tok[1] + "_texTimePP_aMapper" );
			rename $buffer[21] ( "tendInd" + $tok[1] + "_texTimePP_ramp" );
			rename $buffer[22] ( "tendInd" + $tok[1] + "_ampPP_aMapper" );
			rename $buffer[23] ( "tendInd" + $tok[1] + "_ampPP_ramp" );
			rename $buffer[24] ( "tendInd" + $tok[1] + "_colorInBiasPP_aMapper" );
			rename $buffer[25] ( "tendInd" + $tok[1] + "_colorInBiasPP_ramp" );
			rename $buffer[26] ( "tendInd" + $tok[1] + "_opacInBiasPP_aMapper" );
			rename $buffer[27] ( "tendInd" + $tok[1] + "_opacInBiasPP_ramp" );
			rename $buffer[28] ( "tendInd" + $tok[1] + "_radMinPP_aMapper" );
			rename $buffer[29] ( "tendInd" + $tok[1] + "_radMinPP_ramp" );
			rename $buffer[30] ( "tendInd" + $tok[1] + "_radMaxPP_aMapper" );
			rename $buffer[31] ( "tendInd" + $tok[1] + "_radMaxPP_ramp" );

			break;

		// #################################################################################################
		// #    CREATE SMOKE										   					    #
		// #################################################################################################

		case "smoke":
			string $buffer[], $temp[], $explression;

			// create emitter

			$temp = `emitter -pos 0 0 0 -type omni -r 100 -sro 0 -nuv 0 -cye none -cyi 1 -spd 1 -srn 0 -nsp 1 -tsp 0 -mxd 0 -mnd 0 -dx 1 -dy 0 -dz 0 -sp 0`;
			$buffer[0] = $temp[0];

			// set emission attributes

			setAttr ( $buffer[0] + ".rate" ) 5;
			setAttr ( $buffer[0] + ".speedRandom" ) 3;
			setAttr ( $buffer[0] + ".awayFromCenter" ) 1;
			setAttr ( $buffer[0] + ".randomDirection" ) 1;
			setAttr ( $buffer[0] + ".directionalSpeed" ) 1;
			setAttr ( $buffer[0] + ".emitterType" ) 4;
			setAttr ( $buffer[0] + ".volumeShape" ) 1;
			setAttr ( $buffer[0] + ".directionX" ) 0;

			// connect leadParticle and leadParticleShape

			$temp = `particle`;
			$buffer[9] = $temp[0];
			$buffer[11] = $temp[1];

			// connect leadParticleShape to emitter

			connectDynamic -em $buffer[0] $buffer[9];

			// manage leadParticleShape attributes

			setAttr ( $buffer[11] + ".conserve" ) 0.995;
			setAttr ( $buffer[11] + ".particleRenderType" ) 2;
			addAttr -ln velocityRand -at double -smn 0 -smx 2 -dv 0.1 $buffer[11];

			string $ver = `about -v`;

			if ( int ( substring ( $ver, 1, 1 ) ) > 5 )
			{
				dynExpression -s "velocity = velocity + sphrand ( velocityRand )" -rbd $buffer[11];
			}
			else
			{
				dynExpression -s "velocity = velocity + sphrand ( velocityRand )" -r $buffer[11];
			}

			// create leadParticleShape emitter

			select $buffer[9];
			$temp = `emitter -type omni -r 100 -sro 0 -nuv 0 -cye none -cyi 1 -spd 1 -srn 0 -nsp 1 -tsp 0 -mxd 0 -mnd 0 -dx 1 -dy 0 -dz 0 -sp 0`;
			$buffer[10] = $temp[1];

			// set leadParticleShape emitter attribtues

			setAttr ( $buffer[10] + ".rate" ) 20;
			setAttr ( $buffer[10] + ".speed" ) 0;

			// create trailsParticleShape

			$temp = `particle`;
			$buffer[1] = $temp[0];
			$buffer[2] = $temp[1];

			// connect trailsParticleShape to leadParticleShape emitter

			connectDynamic -em $buffer[10] $buffer[2];

			// manage trailsParticleShape attributes

			setAttr ( $buffer[2] + ".conserve" ) 0.995;
			setAttr ( $buffer[2] + ".lifespanMode" ) 2;
			setAttr ( $buffer[2] + ".lifespan" ) 10;
			setAttr ( $buffer[2] + ".lifespanRandom" ) 1;
			setAttr ( $buffer[2] + ".particleRenderType" ) 8;
			addAttr -is true -ln "betterIllumination" -at bool -dv false $buffer[2];
			addAttr -is true -ln "surfaceShading" -at "float" -smn 0 -smx 1 -dv 0 $buffer[2];
			addAttr -is true -ln "threshold" -at "float" -smn 0 -smx 10 -dv 0 $buffer[2];
			addAttr -is true -ln "radius" -at "float" -smn 0 -smx 20 -dv 2 $buffer[2];
			addAttr -ln radiusPP -dt doubleArray $buffer[2];
			addAttr -ln radiusMultPP -dt doubleArray $buffer[2];
			addAttr -ln radiusStartPP -dt doubleArray $buffer[2];
			addAttr -ln radiusMinPP -dt doubleArray $buffer[2];
			addAttr -ln radiusMaxPP -dt doubleArray $buffer[2];
			addAttr -ln opacityPP -dt doubleArray $buffer[2];
			addAttr -ln colorInputBiasPP -dt doubleArray $buffer[2];
			addAttr -ln incandescenceInputBiasPP -dt doubleArray $buffer[2];
			addAttr -ln opacityInputBiasPP -dt doubleArray $buffer[2];
			addAttr -ln amplitudePP -dt doubleArray $buffer[2];
			addAttr -ln textureTimePP -dt doubleArray $buffer[2];
			addAttr -ln textureScalePP -dt doubleArray $buffer[2];
			addAttr -ln textureOriginPP -dt doubleArray $buffer[2];
			addAttr -ln userVector1PP -dt vectorArray $buffer[2];
			addAttr -ln userVector2PP -dt vectorArray $buffer[2];
			addAttr -ln userVector3PP -dt vectorArray $buffer[2];
			addAttr -ln velocityRand -at double -smn 0 -smx 2 -dv 0.075 $buffer[2];
			addAttr -ln radiusMult -at double -smn 0 -smx 20 -dv 2 $buffer[2];
			addAttr -ln radiusMin -at double -smn 0 -smx 20 -dv 0 $buffer[2];
			addAttr -ln radiusMax -at double -smn 0 -smx 20 -dv 3 $buffer[2];
			addAttr -ln colorInputBiasMin -at double -smn -1 -smx 1 -dv 0.2 $buffer[2];
			addAttr -ln colorInputBiasMax -at double -smn -1 -smx 1 -dv 1 $buffer[2];
			addAttr -ln incandescenceInputBiasMin -at double -smn -1 -smx 1 -dv -1 $buffer[2];
			addAttr -ln incandescenceInputBiasMax -at double -smn -1 -smx 1 -dv 1 $buffer[2];
			addAttr -ln opacityInputBiasMin -at double -smn -1 -smx 1 -dv 0.215 $buffer[2];
			addAttr -ln opacityInputBiasMax -at double -smn -1 -smx 1 -dv 1 $buffer[2];
			addAttr -ln amplitudeMin -at double -smn 0 -smx 1 -dv 1 $buffer[2];
			addAttr -ln amplitudeMax -at double -smn 0 -smx 3 -dv 2.5 $buffer[2];
			addAttr -ln textureTimeMin -at double -smn 0 -smx 1 -dv 0 $buffer[2];
			addAttr -ln textureTimeMax -at double -smn 0 -smx 1 -dv 1 $buffer[2];
			addAttr -ln textureScaleMin -at double -smn 0 -smx 10 -dv 1 $buffer[2];
			addAttr -ln textureScaleMax -at double -smn 0 -smx 10 -dv 3 $buffer[2];
			addAttr -ln textureOriginMin -at double -smn 0 -smx 2 -dv 0 $buffer[2];
			addAttr -ln textureOriginMax -at double -smn 0 -smx 2 -dv 1 $buffer[2];

			// create fluidShape

			$buffer[12] = `create3DFluid 5 5 5 10 10 10`;

			// MAYA 5.0 COMPATIBILITY ( THE NEXT TWO LINES ARE NOT NEEDED FOR MAYA 6+ )
			//
			$temp = `ls -sl`;
			$buffer[12] = $temp[0];

			// manage fluidShape attributes

			setAttr ( $buffer[12] + ".densityMethod" ) 3;
			setAttr ( $buffer[12] + ".densityGradient" ) 11;
			setAttr ( $buffer[12] + ".velocityMethod" ) 0;
			setAttr ( $buffer[12] + ".boundaryDraw" ) 4;
			setAttr ( $buffer[12] + ".wireframeDisplay" ) 0;
			setAttr ( $buffer[12] + ".dropoffShape" ) 1;
			setAttr ( $buffer[12] + ".edgeDropoff" ) 0.5;
			setAttr ( $buffer[12] + ".color[0].color_Position" ) 0.408;
			setAttr ( $buffer[12] + ".color[1].color_Color" ) 0 0 0;
			setAttr ( $buffer[12] + ".color[1].color_Position" ) 0.892857;
			setAttr ( $buffer[12] + ".colorInput" ) 2;
			setAttr ( $buffer[12] + ".incandescence[0].incandescence_Color" ) 0.083 0.083 0.083;
			setAttr ( $buffer[12] + ".incandescence[0].incandescence_Position" ) 0.35;
			setAttr ( $buffer[12] + ".incandescence[1].incandescence_Color" ) 0.235 0.235 0.235;
			setAttr ( $buffer[12] + ".incandescence[1].incandescence_Position" ) 0.57;
			setAttr ( $buffer[12] + ".incandescence[2].incandescence_Color" ) 0.242 0.242 0.242;
			setAttr ( $buffer[12] + ".incandescence[2].incandescence_Position" ) 0.785;
			setAttr ( $buffer[12] + ".incandescenceInput" ) 4;
			setAttr ( $buffer[12] + ".opacity[0].opacity_Position" ) 0.329;
			setAttr ( $buffer[12] + ".opacity[1].opacity_FloatValue" ) 0.36;
			setAttr ( $buffer[12] + ".opacity[1].opacity_Position" ) 0.479;
			setAttr ( $buffer[12] + ".opacity[1].opacity_Interp" ) 1;
			setAttr ( $buffer[12] + ".opacity[2].opacity_Position" ) 0.593;
			setAttr ( $buffer[12] + ".opacity[2].opacity_FloatValue" ) 0.6;
			setAttr ( $buffer[12] + ".opacity[3].opacity_Position" ) 0.8;
			setAttr ( $buffer[12] + ".opacity[3].opacity_FloatValue" ) 0.82;
			setAttr ( $buffer[12] + ".opacity[3].opacity_Interp" ) 1;
			setAttr ( $buffer[12] + ".opacity[4].opacity_Position" ) 0.593;
			setAttr ( $buffer[12] + ".opacity[4].opacity_FloatValue" ) 0.6;
			setAttr ( $buffer[12] + ".opacity[4].opacity_Interp" ) 1;
			setAttr ( $buffer[12] + ".opacityInput" ) 4;
			setAttr ( $buffer[12] + ".contrastTolerance" ) 0.02;
			setAttr ( $buffer[12] + ".renderInterpolator" ) 3;
			setAttr ( $buffer[12] + ".colorTexture" ) 1;
			setAttr ( $buffer[12] + ".incandTexture" ) 1;
			setAttr ( $buffer[12] + ".opacityTexture" ) 1;
			setAttr ( $buffer[12] + ".colorTexGain" ) 0.447;
			setAttr ( $buffer[12] + ".opacityTexGain" ) 0.893;
			setAttr ( $buffer[12] + ".ratio" ) 0.505;
			setAttr ( $buffer[12] + ".frequencyRatio" ) 2.2;
			setAttr ( $buffer[12] + ".depthMax" ) 4;
			setAttr ( $buffer[12] + ".inflection" ) 1;
			setAttr ( $buffer[12] + ".frequency" ) 4.126;
			setAttr ( $buffer[12] + ".selfShadowing" ) 1;
			setAttr ( $buffer[12] + ".shadowOpacity" ) 1;
			setAttr ( $buffer[12] + ".realLights" ) 0;
			setAttr ( $buffer[12] + ".textureScaleX" ) 3;
			setAttr ( $buffer[12] + ".textureScaleY" ) 3;
			setAttr ( $buffer[12] + ".textureScaleZ" ) 3;
			setAttr ( $buffer[12] + ".castsShadows" ) 0;
			setAttr ( $buffer[12] + ".receiveShadows" ) 0;
			setAttr ( $buffer[12] + ".primaryVisibility" ) 0;
			setAttr ( $buffer[12] + ".visibleInReflections" ) 0;
			setAttr ( $buffer[12] + ".visibleInRefractions" ) 0;
			setAttr ( $buffer[12] + ".directionalLightX" ) 0;
			setAttr ( $buffer[12] + ".directionalLightY" ) 1;
			setAttr ( $buffer[12] + ".directionalLightZ" ) 0;

			// assign fluidShape to trailsParticleShape

			$temp = `listConnections -s 0 -d 1 ( $buffer[12] + ".outColor" )`;
			select $buffer[2];
			sets -e -forceElement $temp[0];

			// create particleSamplerInfo

			$buffer[13] = `shadingNode -asUtility particleSamplerInfo`;

			// create arrayMapper for radiusMultPP

			$temp = `arrayMapper -target $buffer[2] -destAttr radiusMultPP -inputV ageNormalized -type ramp`;
			$buffer[3] = $temp[0];

			// create ramp for radiusMultPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[3] + ".computeNodeColor" )`;
			$buffer[4] = $temp[0];

			setAttr ( $buffer[4] + ".colorEntryList[0].color" ) 0.5 0.5 0.5;
			removeMultiInstance -break true ( $buffer[4] + ".colorEntryList[1]" );
			setAttr ( $buffer[4] + ".colorEntryList[2].color" ) 1 1 1;
			setAttr ( $buffer[4] + ".colorEntryList[2].position" ) 1;

			// create arrayMapper for radiusStartPP

			$temp = `arrayMapper -target $buffer[2] -destAttr radiusStartPP -inputV ageNormalized -type ramp`;
			$buffer[5] = $temp[0];

			// create ramp for radiusStartPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[5] + ".computeNodeColor" )`;
			$buffer[6] = $temp[0];

			setAttr ( $buffer[6] + ".colorEntryList[0].color" ) 0.9 0.9 0.9;
			removeMultiInstance -break true ( $buffer[6] + ".colorEntryList[1]" );
			setAttr ( $buffer[6] + ".colorEntryList[2].color" ) 1 1 1;
			setAttr ( $buffer[6] + ".colorEntryList[2].position" ) 1;
			setAttr ( $buffer[6] + ".noise" ) 1;

			// create arrayMapper for opacityPP

			$temp = `arrayMapper -target $buffer[2] -destAttr opacityPP -inputV ageNormalized -type ramp`;
			$buffer[7] = $temp[0];

			// create arrayMapper for radiusMinPP

			$temp = `arrayMapper -target $buffer[2] -destAttr radiusMinPP -inputV birthTime -type ramp`;
			$buffer[28] = $temp[0];

			// create ramp for radiusMinPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[28] + ".computeNodeColor" )`;
			$buffer[29] = $temp[0];

			setAttr ( $buffer[29] + ".colorEntryList[0].color" ) 1 1 1;
			removeMultiInstance -break true ( $buffer[29] + ".colorEntryList[1]" );
			removeMultiInstance -break true ( $buffer[29] + ".colorEntryList[2]" );
			setAttr ( $buffer[29] + ".noise" ) 1;

			// create arrayMapper for radiusMaxPP

			$temp = `arrayMapper -target $buffer[2] -destAttr radiusMaxPP -inputV birthTime -type ramp`;
			$buffer[30] = $temp[0];

			// create ramp for radiusMaxPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[30] + ".computeNodeColor" )`;
			$buffer[31] = $temp[0];

			setAttr ( $buffer[31] + ".colorEntryList[0].color" ) 1 1 1;
			removeMultiInstance -break true ( $buffer[31] + ".colorEntryList[1]" );
			removeMultiInstance -break true ( $buffer[31] + ".colorEntryList[2]" );
			setAttr ( $buffer[31] + ".noise" ) 1;

			// create ramp for opacityPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[7] + ".computeNodeColor" )`;
			$buffer[8] = $temp[0];

			setAttr ( $buffer[8] + ".colorEntryList[0].color" ) 1 1 1;
			setAttr ( $buffer[8] + ".colorEntryList[1].color" ) 0.2 0.2 0.2;
			setAttr ( $buffer[8] + ".colorEntryList[1].position" ) 0.08;
			setAttr ( $buffer[8] + ".colorEntryList[2].color" ) 1 1 1;
			setAttr ( $buffer[8] + ".colorEntryList[2].position" ) 0.55;

			// create connections between particleSamplerInfo and opacityPP

			connectAttr -f ( $buffer[13] + ".opacityPP" ) ( $buffer[12] + ".transparencyR" );
			connectAttr -f ( $buffer[13] + ".opacityPP" ) ( $buffer[12] + ".transparencyG" );
			connectAttr -f ( $buffer[13] + ".opacityPP" ) ( $buffer[12] + ".transparencyB" );

			// create arrayMapper for textureOriginPP

			$temp = `arrayMapper -target $buffer[2] -destAttr textureOriginPP -inputV ageNormalized -type ramp`;
			$buffer[14] = $temp[0];

			connectAttr -f ( $buffer[2] + ".textureOriginMin" ) ( $buffer[14] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".textureOriginMax" ) ( $buffer[14] + ".maxValue" );

			// create ramp for textureOriginPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[14] + ".computeNodeColor" )`;
			$buffer[15] = $temp[0];

			setAttr ( $buffer[15] + ".colorEntryList[0].color" ) 1 1 1;
			removeMultiInstance -break true ( $buffer[15] + ".colorEntryList[1]" );
			setAttr ( $buffer[15] + ".colorEntryList[2].color" ) 0 0 0;
			setAttr ( $buffer[15] + ".colorEntryList[2].position" ) 1;
			setAttr ( $buffer[15] + ".noise" ) 1;

			// create connections between particleSamplerInfo and textureOriginPP

			connectAttr -f ( $buffer[13] + ".userVector3PPX" ) ( $buffer[12] + ".textureOriginX" );
			connectAttr -f ( $buffer[13] + ".userVector3PPX" ) ( $buffer[12] + ".textureOriginY" );
			connectAttr -f ( $buffer[13] + ".userVector3PPX" ) ( $buffer[12] + ".textureOriginZ" );

			// create arrayMapper for textureScalePP

			$temp = `arrayMapper -target $buffer[2] -destAttr textureScalePP -inputV ageNormalized -type ramp`;
			$buffer[16] = $temp[0];

			connectAttr -f ( $buffer[2] + ".textureScaleMin" ) ( $buffer[16] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".textureScaleMax" ) ( $buffer[16] + ".maxValue" );

			// create ramp for textureScalePP

			$temp = `listConnections -s 1 -d 0 ( $buffer[16] + ".computeNodeColor" )`;
			$buffer[17] = $temp[0];

			setAttr ( $buffer[17] + ".colorEntryList[0].color" ) 1 1 1;
			removeMultiInstance -break true ( $buffer[17] + ".colorEntryList[1]" );
			setAttr ( $buffer[17] + ".colorEntryList[2].color" ) 0.5 0.5 0.5;
			setAttr ( $buffer[17] + ".colorEntryList[2].position" ) 1;

			// create connections between particleSamplerInfo and textureScalePP

			connectAttr -f ( $buffer[13] + ".userVector2PPZ" ) ( $buffer[12] + ".textureScaleX" );
			connectAttr -f ( $buffer[13] + ".userVector2PPZ" ) ( $buffer[12] + ".textureScaleY" );
			connectAttr -f ( $buffer[13] + ".userVector2PPZ" ) ( $buffer[12] + ".textureScaleZ" );

			// create arrayMapper for incandescenceInputBiasPP

			$temp = `arrayMapper -target $buffer[2] -destAttr incandescenceInputBiasPP -inputV ageNormalized -type ramp`;
			$buffer[18] = $temp[0];

			connectAttr -f ( $buffer[2] + ".incandescenceInputBiasMin" ) ( $buffer[18] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".incandescenceInputBiasMax" ) ( $buffer[18] + ".maxValue" );

			// create ramp for incandescenceInputBiasPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[18] + ".computeNodeColor" )`;
			$buffer[19] = $temp[0];

			setAttr ( $buffer[19] + ".interpolation" ) 3;
			setAttr ( $buffer[19] + ".colorEntryList[0].color" ) 0.85 0.85 0.85;
			setAttr ( $buffer[19] + ".colorEntryList[1].color" ) 0.5 0.5 0.5;
			setAttr ( $buffer[19] + ".colorEntryList[1].position" ) 0.1;
			setAttr ( $buffer[19] + ".colorEntryList[2].color" ) 0 0 0;
			setAttr ( $buffer[19] + ".colorEntryList[2].position" ) 1;

			// create connections between particleSamplerInfo and incandescenceInputBiasPP

			connectAttr -f ( $buffer[13] + ".userVector1PPY" ) ( $buffer[12] + ".incandescenceInputBias" );

			// create arrayMapper for textureTimePP

			$temp = `arrayMapper -target $buffer[2] -destAttr textureTimePP -inputV ageNormalized -type ramp`;
			$buffer[20] = $temp[0];

			connectAttr -f ( $buffer[2] + ".textureTimeMin" ) ( $buffer[20] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".textureTimeMax" ) ( $buffer[20] + ".maxValue" );

			// create ramp for textureTimePP

			$temp = `listConnections -s 1 -d 0 ( $buffer[20] + ".computeNodeColor" )`;
			$buffer[21] = $temp[0];

			setAttr ( $buffer[21] + ".interpolation" ) 3;
			setAttr ( $buffer[21] + ".colorEntryList[0].color" ) 0 0 0;
			removeMultiInstance -break true ( $buffer[21] + ".colorEntryList[1]" );
			setAttr ( $buffer[21] + ".colorEntryList[2].color" ) 0.75 0.75 0.75;
			setAttr ( $buffer[21] + ".colorEntryList[2].position" ) 1;

			// create connections between particleSamplerInfo and textureTimePP

			connectAttr -f ( $buffer[13] + ".userVector2PPY" ) ( $buffer[12] + ".textureTime" );

			// create arrayMapper for amplitudePP

			$temp = `arrayMapper -target $buffer[2] -destAttr amplitudePP -inputV ageNormalized -type ramp`;
			$buffer[22] = $temp[0];

			connectAttr -f ( $buffer[2] + ".amplitudeMin" ) ( $buffer[22] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".amplitudeMax" ) ( $buffer[22] + ".maxValue" );

			// create ramp for amplitudePP

			$temp = `listConnections -s 1 -d 0 ( $buffer[22] + ".computeNodeColor" )`;
			$buffer[23] = $temp[0];

			setAttr ( $buffer[23] + ".colorEntryList[0].color" ) 0 0 0;
			removeMultiInstance -break true ( $buffer[23] + ".colorEntryList[1]" );
			setAttr ( $buffer[23] + ".colorEntryList[2].color" ) 1 1 1;
			setAttr ( $buffer[23] + ".colorEntryList[2].position" ) 1;

			// create connections between particleSamplerInfo and amplitudePP

			connectAttr -f ( $buffer[13] + ".userVector2PPX" ) ( $buffer[12] + ".amplitude" );

			// create arrayMapper for colorInputBiasPP

			$temp = `arrayMapper -target $buffer[2] -destAttr colorInputBiasPP -inputV ageNormalized -type ramp`;
			$buffer[24] = $temp[0];

			connectAttr -f ( $buffer[2] + ".colorInputBiasMin" ) ( $buffer[24] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".colorInputBiasMax" ) ( $buffer[24] + ".maxValue" );

			// create ramp for colorInputBiasPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[24] + ".computeNodeColor" )`;
			$buffer[25] = $temp[0];

			setAttr ( $buffer[25] + ".colorEntryList[0].color" ) 0 0 0;
			removeMultiInstance -break true ( $buffer[25] + ".colorEntryList[1]" );
			removeMultiInstance -break true ( $buffer[25] + ".colorEntryList[2]" );

			// create connections between particleSamplerInfo and userVector2PP

			connectAttr -f ( $buffer[13] + ".userVector1PPX" ) ( $buffer[12] + ".colorInputBias" );

			// create arrayMapper for opacityInputBiasPP

			$temp = `arrayMapper -target $buffer[2] -destAttr opacityInputBiasPP -inputV ageNormalized -type ramp`;
			$buffer[26] = $temp[0];

			connectAttr -f ( $buffer[2] + ".opacityInputBiasMin" ) ( $buffer[26] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".opacityInputBiasMax" ) ( $buffer[26] + ".maxValue" );

			// create ramp for opacityInputBiasPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[26] + ".computeNodeColor" )`;
			$buffer[27] = $temp[0];

			setAttr ( $buffer[27] + ".colorEntryList[0].color" ) 0 0 0;
			removeMultiInstance -break true ( $buffer[27] + ".colorEntryList[1]" );
			removeMultiInstance -break true ( $buffer[27] + ".colorEntryList[2]" );

			// create connections between particleSamplerInfo and opacityInputBiasPP

			connectAttr -f ( $buffer[13] + ".userVector1PPZ" ) ( $buffer[12] + ".opacityInputBias" );

			// set expressions

			$explression = "radiusPP = clamp ( radiusMin * radiusMinPP, radiusMax * radiusMaxPP, 0.1 * radius * radiusStartPP );\n";
			$explression += "userVector3PP = << textureOriginPP, 0, 0 >>;";

			dynExpression -s $explression -c $buffer[2];

			$explression = "velocity += sphrand ( velocityRand );\n";
			$explression += "radiusPP = clamp ( radiusMin * radiusMinPP, radiusMax * radiusMaxPP, radiusPP + 0.01 * radiusMultPP * radiusMult );\n";
			$explression += "userVector1PP = << colorInputBiasPP, incandescenceInputBiasPP, opacityInputBiasPP >>;\n";
			$explression += "userVector2PP = << amplitudePP, textureTimePP, textureScalePP >>;";

			string $ver = `about -v`;

			if ( int ( substring ( $ver, 1, 1 ) ) > 5 )
			{
				dynExpression -s $explression -rbd $buffer[2];
			}
			else
			{
				dynExpression -s $explression -r $buffer[2];
			}

			string $groupName = `group -n "smoke#" $buffer[0] $buffer[1] $buffer[9] $buffer[12]`;
			string $tok[];
			tokenize $groupName "e" $tok;

			// rename nodes

			rename $buffer[0] ( "smoke" + $tok[1] + "_leadEmitter" );
			rename $buffer[1] ( "smoke" + $tok[1] + "_trailParticle" );
			rename $buffer[3] ( "smoke" + $tok[1] + "_radMultPP_aMapper" );
			rename $buffer[4] ( "smoke" + $tok[1] + "_radMultPP_ramp" );
			rename $buffer[5] ( "smoke" + $tok[1] + "_radStartPP_aMapper" );
			rename $buffer[6] ( "smoke" + $tok[1] + "_radStartPP_ramp" );
			rename $buffer[7] ( "smoke" + $tok[1] + "_opacPP_aMapper" );
			rename $buffer[8] ( "smoke" + $tok[1] + "_opacPP_ramp" );
			rename $buffer[9] ( "smoke" + $tok[1] + "_leadParticle" );
			rename $buffer[10] ( "smoke" + $tok[1] + "_trailEmitter" );
			rename $buffer[12] ( "smoke" + $tok[1] + "_fluid" );
			rename $buffer[14] ( "smoke" + $tok[1] + "_texOrigPP_aMapper" );
			rename $buffer[15] ( "smoke" + $tok[1] + "_texOrigPP_ramp" );
			rename $buffer[16] ( "smoke" + $tok[1] + "_texScalePP_aMapper" );
			rename $buffer[17] ( "smoke" + $tok[1] + "_texScalePP_ramp" );
			rename $buffer[18] ( "smoke" + $tok[1] + "_incanInBiasPP_aMapper" );
			rename $buffer[19] ( "smoke" + $tok[1] + "_incanInBiasPP_ramp" );
			rename $buffer[20] ( "smoke" + $tok[1] + "_texTimePP_aMapper" );
			rename $buffer[21] ( "smoke" + $tok[1] + "_texTimePP_ramp" );
			rename $buffer[22] ( "smoke" + $tok[1] + "_ampPP_aMapper" );
			rename $buffer[23] ( "smoke" + $tok[1] + "_ampPP_ramp" );
			rename $buffer[24] ( "smoke" + $tok[1] + "_colorInBiasPP_aMapper" );
			rename $buffer[25] ( "smoke" + $tok[1] + "_colorInBiasPP_ramp" );
			rename $buffer[26] ( "smoke" + $tok[1] + "_opacInBiasPP_aMapper" );
			rename $buffer[27] ( "smoke" + $tok[1] + "_opacInBiasPP_ramp" );
			rename $buffer[28] ( "smoke" + $tok[1] + "_radMinPP_aMapper" );
			rename $buffer[29] ( "smoke" + $tok[1] + "_radMinPP_ramp" );
			rename $buffer[30] ( "smoke" + $tok[1] + "_radMaxPP_aMapper" );
			rename $buffer[31] ( "smoke" + $tok[1] + "_radMaxPP_ramp" );

			break;

		// #################################################################################################
		// #    CREATE FIRE										   						    #
		// #################################################################################################

		case "fire":
			string $buffer[], $temp[], $current;

			$buffer[0] = `create3DFluid 40 60 40 100 120 100`;

			// MAYA 5.0 COMPATIBILITY ( NEXT LINE IS NOT NEEDED FOR MAYA 6+ )
			//
			$buffer = `ls -sl`;

			setAttr ( $buffer[12] + ".boundaryX" ) 0;
			setAttr ( $buffer[12] + ".boundaryY" ) 2;
			setAttr ( $buffer[12] + ".boundaryZ" ) 0;
			setAttr ( $buffer[12] + ".temperatureMethod" ) 2;
			setAttr ( $buffer[12] + ".fuelMethod" ) 2;

			if ( ( float ) `about -v` >= 7 )
			{
				setAttr ( $buffer[12] + ".velocityDamp" ) 0.0125;
				setAttr ( $buffer[12] + ".highDetailSolve" ) 3;
			}
			else
			{
				setAttr ( $buffer[12] + ".velocityDamp" ) 0.05;
			}

			setAttr ( $buffer[12] + ".simulationRateScale" ) 4;
			setAttr ( $buffer[12] + ".densityScale" ) 0.579;
			setAttr ( $buffer[12] + ".densityBuoyancy" ) 9;
			setAttr ( $buffer[12] + ".densityDissipation" ) 0.025;
			setAttr ( $buffer[12] + ".densityDiffusion" ) 0;
			setAttr ( $buffer[12] + ".velocitySwirl" ) 7.273;
			setAttr ( $buffer[12] + ".turbulenceStrength" ) 0.008;
			setAttr ( $buffer[12] + ".turbulenceFrequency" ) 0.2;
			setAttr ( $buffer[12] + ".turbulenceSpeed" ) 0.2;
			setAttr ( $buffer[12] + ".temperatureScale" ) 1.802;
			setAttr ( $buffer[12] + ".buoyancy" ) 12;
			setAttr ( $buffer[12] + ".temperatureDissipation" ) 0.141;
			setAttr ( $buffer[12] + ".temperatureDiffusion" ) 0.349;
			setAttr ( $buffer[12] + ".temperatureTurbulence" ) 0.1;
			setAttr ( $buffer[12] + ".fuelScale" ) 1.934;
			setAttr ( $buffer[12] + ".reactionSpeed" ) 0.926;
			setAttr ( $buffer[12] + ".transparency" ) 0.711 0.711 0.711;
			setAttr ( $buffer[12] + ".dropoffShape" ) 2;
			setAttr ( $buffer[12] + ".edgeDropoff" ) 0.2;
			setAttr ( $buffer[12] + ".color[0].color_Color" ) 0 0 0;
			setAttr ( $buffer[12] + ".color[0].color_Interp" ) 1;
			setAttr ( $buffer[12] + ".color[1].color_Color" ) 0.482 0.3014 0.214972;
			setAttr ( $buffer[12] + ".color[1].color_Position" ) 0.464;
			setAttr ( $buffer[12] + ".color[1].color_Interp" ) 1;
			setAttr ( $buffer[12] + ".color[2].color_Color" ) 0.178 0.178 0.178;
			setAttr ( $buffer[12] + ".color[2].color_Position" ) 1;
			setAttr ( $buffer[12] + ".color[2].color_Interp" ) 1;
			setAttr ( $buffer[12] + ".colorInput" ) 5;
			setAttr ( $buffer[12] + ".incandescence[0].incandescence_Color" ) 0.098 0.0612805 0.043708;
			setAttr ( $buffer[12] + ".incandescence[0].incandescence_Position" ) 0.743;
			setAttr ( $buffer[12] + ".incandescence[1].incandescence_Color" ) 2.5 1.468592 0.975;
			setAttr ( $buffer[12] + ".incandescence[1].incandescence_Position" ) 0.829;
			setAttr ( $buffer[12] + ".incandescence[2].incandescence_Color" ) 0 0 0 ;
			setAttr ( $buffer[12] + ".incandescence[2].incandescence_Position" ) 0.907;
			setAttr ( $buffer[12] + ".incandescence[2].incandescence_Interp" ) 2;
			setAttr ( $buffer[12] + ".incandescence[3].incandescence_Color" ) 0 0.35 0.75;
			setAttr ( $buffer[12] + ".incandescence[3].incandescence_Position" ) 1;
			setAttr ( $buffer[12] + ".incandescence[3].incandescence_Interp" ) 2;
			setAttr ( $buffer[12] + ".incandescenceInput" ) 6;
			setAttr ( $buffer[12] + ".incandescenceInputBias" ) 0.838;
			setAttr ( $buffer[12] + ".opacity[0].opacity_Position" ) 0.071;
			setAttr ( $buffer[12] + ".opacity[0].opacity_FloatValue" ) 0;
			setAttr ( $buffer[12] + ".opacity[0].opacity_Interp" ) 1;
			setAttr ( $buffer[12] + ".opacity[1].opacity_Position" ) 0.164;
			setAttr ( $buffer[12] + ".opacity[1].opacity_FloatValue" ) 0.1;
			setAttr ( $buffer[12] + ".opacity[1].opacity_Interp" ) 1;
			setAttr ( $buffer[12] + ".opacity[2].opacity_Position" ) 0.2;
			setAttr ( $buffer[12] + ".opacity[2].opacity_FloatValue" ) 0.44;
			setAttr ( $buffer[12] + ".opacity[2].opacity_Interp" ) 1;
			setAttr ( $buffer[12] + ".opacity[3].opacity_Position" ) 0.271;
			setAttr ( $buffer[12] + ".opacity[3].opacity_FloatValue" ) 0.68;
			setAttr ( $buffer[12] + ".opacity[3].opacity_Interp" ) 1;
			setAttr ( $buffer[12] + ".opacity[4].opacity_Position" ) 0.371;
			setAttr ( $buffer[12] + ".opacity[4].opacity_FloatValue" ) 0.36;
			setAttr ( $buffer[12] + ".opacity[4].opacity_Interp" ) 1;
			setAttr ( $buffer[12] + ".opacity[5].opacity_Position" ) 1;
			setAttr ( $buffer[12] + ".opacity[5].opacity_FloatValue" ) 0;
			setAttr ( $buffer[12] + ".opacity[5].opacity_Interp" ) 1;
			setAttr ( $buffer[12] + ".opacityInput" ) 5;
			setAttr ( $buffer[12] + ".opacityInputBias" ) 0.351;
			setAttr ( $buffer[12] + ".renderInterpolator" ) 3;
			setAttr ( $buffer[12] + ".opacityTexture" ) 1;
			setAttr ( $buffer[12] + ".textureType" ) 1;
			setAttr ( $buffer[12] + ".opacityTexGain" ) 0.350;
			setAttr ( $buffer[12] + ".realLights" ) 0;

			string $exp1 = `expression -s ( $buffer[0] + ".textureTime = time * 2.5" ) -ae 1 -uc all`;

			string $groupName = `group -n "fire#" $buffer[0]`;

			$temp = `fluidEmitter -pos 11 -46.571 -4.538 -type volume -der 3.5 -her 2 -fer 2 -fdr 2 -r 100.0 -cye none -cyi 1 -mxd 1 -mnd 0 -vsh cube -vof 0 0 0 -vsw 360 -tsr 0.5`;
			connectDynamic -em $temp[0] $buffer[0];
			setAttr ( $temp[0] + ".turbulence" ) 5;
			parent $temp[0] $buffer[0];

			$temp = `fluidEmitter -pos 15 -46.571 0 -type volume -der 3.5 -her 2 -fer 2 -fdr 2 -r 100.0 -cye none -cyi 1 -mxd 1 -mnd 0 -vsh cube -vof 0 0 0 -vsw 360 -tsr 0.5`;
			connectDynamic -em $temp[0] $buffer[0];
			setAttr ( $temp[0] + ".turbulence" ) 5;
			parent $temp[0] $buffer[0];

			$temp = `fluidEmitter -pos -12 -46.571 -8.538 -type volume -der 3.5 -her 2 -fer 2 -fdr 2 -r 100.0 -cye none -cyi 1 -mxd 1 -mnd 0 -vsh cube -vof 0 0 0 -vsw 360 -tsr 0.5`;
			connectDynamic -em $temp[0] $buffer[0];
			setAttr ( $temp[0] + ".turbulence" ) 5;
			parent $temp[0] $buffer[0];

			$temp = `fluidEmitter -pos 11 -46.571 -12.538 -type volume -der 3.5 -her 2 -fer 2 -fdr 2 -r 100.0 -cye none -cyi 1 -mxd 1 -mnd 0 -vsh cube -vof 0 0 0 -vsw 360 -tsr 0.5`;
			connectDynamic -em $temp[0] $buffer[0];
			setAttr ( $temp[0] + ".turbulence" ) 5;
			parent $temp[0] $buffer[0];

			$temp = `fluidEmitter -pos -8 -46.571 13.726 -type volume -der 3.5 -her 2 -fer 2 -fdr 2 -r 100.0 -cye none -cyi 1 -mxd 1 -mnd 0 -vsh cube -vof 0 0 0 -vsw 360 -tsr 0.5`;
			connectDynamic -em $temp[0] $buffer[0];
			setAttr ( $temp[0] + ".turbulence" ) 5;
			parent $temp[0] $buffer[0];

			$temp = `fluidEmitter -pos 15 -46.571 8.726 -type volume -der 3.5 -her 2 -fer 2 -fdr 2 -r 100.0 -cye none -cyi 1 -mxd 1 -mnd 0 -vsh cube -vof 0 0 0 -vsw 360 -tsr 0.5`;
			connectDynamic -em $temp[0] $buffer[0];
			setAttr ( $temp[0] + ".turbulence" ) 5;
			parent $temp[0] $buffer[0];

			$temp = `fluidEmitter -pos 11 -46.571 4.726 -type volume -der 3.5 -her 2 -fer 2 -fdr 2 -r 100.0 -cye none -cyi 1 -mxd 1 -mnd 0 -vsh cube -vof 0 0 0 -vsw 360 -tsr 0.5`;
			connectDynamic -em $temp[0] $buffer[0];
			setAttr ( $temp[0] + ".turbulence" ) 5;
			parent $temp[0] $buffer[0];

			$temp = `fluidEmitter -pos 3 -46.571 -12.538 -type volume -der 3.5 -her 2 -fer 2 -fdr 2 -r 100.0 -cye none -cyi 1 -mxd 1 -mnd 0 -vsh cube -vof 0 0 0 -vsw 360 -tsr 0.5`;
			connectDynamic -em $temp[0] $buffer[0];
			setAttr ( $temp[0] + ".turbulence" ) 5;
			parent $temp[0] $buffer[0];

			$temp = `fluidEmitter -pos 7 -46.571 8.726 -type volume -der 3.5 -her 2 -fer 2 -fdr 2 -r 100.0 -cye none -cyi 1 -mxd 1 -mnd 0 -vsh cube -vof 0 0 0 -vsw 360 -tsr 0.5`;
			connectDynamic -em $temp[0] $buffer[0];
			setAttr ( $temp[0] + ".turbulence" ) 5;
			parent $temp[0] $buffer[0];

			$temp = `fluidEmitter -pos -2 -46.571 13.726 -type volume -der 3.5 -her 2 -fer 4 -fdr 2 -r 100.0 -cye none -cyi 1 -mxd 1 -mnd 0 -vsh cube -vof 0 0 0 -vsw 360 -tsr 0.5`;
			connectDynamic -em $temp[0] $buffer[0];
			setAttr ( $temp[0] + ".turbulence" ) 5;
			parent $temp[0] $buffer[0];

			$temp = `fluidEmitter -pos -2 -46.571 4.726 -type volume -der 3.5 -her 2 -fer 2 -fdr 2 -r 100.0 -cye none -cyi 1 -mxd 1 -mnd 0 -vsh cube -vof 0 0 0 -vsw 360 -tsr 0.5`;
			connectDynamic -em $temp[0] $buffer[0];
			setAttr ( $temp[0] + ".turbulence" ) 5;
			parent $temp[0] $buffer[0];

			$temp = `fluidEmitter -pos 11 -46.571 13.726 -type volume -der 3.5 -her 2 -fer 2 -fdr 2 -r 100.0 -cye none -cyi 1 -mxd 1 -mnd 0 -vsh cube -vof 0 0 0 -vsw 360 -tsr 0.5`;
			connectDynamic -em $temp[0] $buffer[0];
			setAttr ( $temp[0] + ".turbulence" ) 5;
			parent $temp[0] $buffer[0];

			$temp = `fluidEmitter -pos 7 -46.571 0 -type volume -der 3.5 -her 2 -fer 2 -fdr 2 -r 100.0 -cye none -cyi 1 -mxd 1 -mnd 0 -vsh cube -vof 0 0 0 -vsw 360 -tsr 0.5`;
			connectDynamic -em $temp[0] $buffer[0];
			setAttr ( $temp[0] + ".turbulence" ) 5;
			parent $temp[0] $buffer[0];

			$temp = `fluidEmitter -pos 7 -46.571 -8.538 -type volume -der 3.5 -her 2 -fer 2 -fdr 2 -r 100.0 -cye none -cyi 1 -mxd 1 -mnd 0 -vsh cube -vof 0 0 0 -vsw 360 -tsr 0.5`;
			connectDynamic -em $temp[0] $buffer[0];
			setAttr ( $temp[0] + ".turbulence" ) 5;
			parent $temp[0] $buffer[0];

			$temp = `fluidEmitter -pos 15 -46.571 -8.538 -type volume -der 3.5 -her 2 -fer 2 -fdr 2 -r 100.0 -cye none -cyi 1 -mxd 1 -mnd 0 -vsh cube -vof 0 0 0 -vsw 360 -tsr 0.5`;
			connectDynamic -em $temp[0] $buffer[0];
			setAttr ( $temp[0] + ".turbulence" ) 5;
			parent $temp[0] $buffer[0];

			$temp = `fluidEmitter -pos -8 -46.571 4.726 -type volume -der 3.5 -her 2 -fer 2 -fdr 2 -r 100.0 -cye none -cyi 1 -mxd 1 -mnd 0 -vsh cube -vof 0 0 0 -vsw 360 -tsr 0.5`;
			connectDynamic -em $temp[0] $buffer[0];
			setAttr ( $temp[0] + ".turbulence" ) 5;
			parent $temp[0] $buffer[0];

			$temp = `fluidEmitter -pos -12 -46.571 0 -type volume -der 3.5 -her 2 -fer 2 -fdr 2 -r 100.0 -cye none -cyi 1 -mxd 1 -mnd 0 -vsh cube -vof 0 0 0 -vsw 360 -tsr 0.5`;
			connectDynamic -em $temp[0] $buffer[0];
			setAttr ( $temp[0] + ".turbulence" ) 5;
			parent $temp[0] $buffer[0];

			$temp = `fluidEmitter -pos -4 -46.571 8.726 -type volume -der 3.5 -her 2 -fer 2 -fdr 2 -r 100.0 -cye none -cyi 1 -mxd 1 -mnd 0 -vsh cube -vof 0 0 0 -vsw 360 -tsr 0.5`;
			connectDynamic -em $temp[0] $buffer[0];
			setAttr ( $temp[0] + ".turbulence" ) 5;
			parent $temp[0] $buffer[0];

			$temp = `fluidEmitter -pos 3 -46.571 -4.538 -type volume -der 3.5 -her 2 -fer 2 -fdr 2 -r 100.0 -cye none -cyi 1 -mxd 1 -mnd 0 -vsh cube -vof 0 0 0 -vsw 360 -tsr 0.5`;
			connectDynamic -em $temp[0] $buffer[0];
			setAttr ( $temp[0] + ".turbulence" ) 5;
			parent $temp[0] $buffer[0];

			$temp = `fluidEmitter -pos 3 -46.571 13.726 -type volume -der 3.5 -her 2 -fer 2 -fdr 2 -r 100.0 -cye none -cyi 1 -mxd 1 -mnd 0 -vsh cube -vof 0 0 0 -vsw 360 -tsr 0.5`;
			connectDynamic -em $temp[0] $buffer[0];
			setAttr ( $temp[0] + ".turbulence" ) 5;
			parent $temp[0] $buffer[0];

			$temp = `fluidEmitter -pos 3 -46.571 4.726 -type volume -der 3.5 -her 2 -fer 2 -fdr 2 -r 100.0 -cye none -cyi 1 -mxd 1 -mnd 0 -vsh cube -vof 0 0 0 -vsw 360 -tsr 0.5`;
			connectDynamic -em $temp[0] $buffer[0];
			setAttr ( $temp[0] + ".turbulence" ) 5;
			parent $temp[0] $buffer[0];

			$temp = `fluidEmitter -pos -2 -46.571 13.726 -type volume -der 3.5 -her 2 -fer 2 -fdr 2 -r 100.0 -cye none -cyi 1 -mxd 1 -mnd 0 -vsh cube -vof 0 0 0 -vsw 360 -tsr 0.5`;
			connectDynamic -em $temp[0] $buffer[0];
			setAttr ( $temp[0] + ".turbulence" ) 5;
			parent $temp[0] $buffer[0];

			$temp = `fluidEmitter -pos 0 -46.571 8.726 -type volume -der 3.5 -her 2 -fer 2 -fdr 2 -r 100.0 -cye none -cyi 1 -mxd 1 -mnd 0 -vsh cube -vof 0 0 0 -vsw 360 -tsr 0.5`;
			connectDynamic -em $temp[0] $buffer[0];
			setAttr ( $temp[0] + ".turbulence" ) 5;
			parent $temp[0] $buffer[0];

			$temp = `fluidEmitter -pos -8 -46.571 -12.538 -type volume -der 3.5 -her 2 -fer 2 -fdr 2 -r 100.0 -cye none -cyi 1 -mxd 1 -mnd 0 -vsh cube -vof 0 0 0 -vsw 360 -tsr 0.5`;
			connectDynamic -em $temp[0] $buffer[0];
			setAttr ( $temp[0] + ".turbulence" ) 5;
			parent $temp[0] $buffer[0];

			$temp = `fluidEmitter -pos -4 -46.571 0 -type volume -der 3.5 -her 2 -fer 2 -fdr 2 -r 100.0 -cye none -cyi 1 -mxd 1 -mnd 0 -vsh cube -vof 0 0 0 -vsw 360 -tsr 0.5`;
			connectDynamic -em $temp[0] $buffer[0];
			setAttr ( $temp[0] + ".turbulence" ) 5;
			parent $temp[0] $buffer[0];

			$temp = `fluidEmitter -pos -2 -46.571 -4.538 -type volume -der 3.5 -her 2 -fer 2 -fdr 2 -r 100.0 -cye none -cyi 1 -mxd 1 -mnd 0 -vsh cube -vof 0 0 0 -vsw 360 -tsr 0.5`;
			connectDynamic -em $temp[0] $buffer[0];
			setAttr ( $temp[0] + ".turbulence" ) 5;
			parent $temp[0] $buffer[0];

			$temp = `fluidEmitter -pos 0 -46.571 0 -type volume -der 3.5 -her 2 -fer 2 -fdr 2 -r 100.0 -cye none -cyi 1 -mxd 1 -mnd 0 -vsh cube -vof 0 0 0 -vsw 360 -tsr 0.5`;
			connectDynamic -em $temp[0] $buffer[0];
			setAttr ( $temp[0] + ".turbulence" ) 5;
			parent $temp[0] $buffer[0];

			$temp = `fluidEmitter -pos 0 -46.571 -8.538 -type volume -der 3.5 -her 2 -fer 4 -fdr 2 -r 100.0 -cye none -cyi 1 -mxd 1 -mnd 0 -vsh cube -vof 0 0 0 -vsw 360 -tsr 0.5`;
			connectDynamic -em $temp[0] $buffer[0];
			setAttr ( $temp[0] + ".turbulence" ) 5;
			parent $temp[0] $buffer[0];

			$temp = `fluidEmitter -pos -4 -46.571 -8.538 -type volume -der 3.5 -her 2 -fer 4 -fdr 2 -r 100.0 -cye none -cyi 1 -mxd 1 -mnd 0 -vsh cube -vof 0 0 0 -vsw 360 -tsr 0.5`;
			connectDynamic -em $temp[0] $buffer[0];
			setAttr ( $temp[0] + ".turbulence" ) 5;
			parent $temp[0] $buffer[0];

			$temp = `fluidEmitter -pos -8 -46.571 -4.538 -type volume -der 3.5 -her 2 -fer 4 -fdr 2 -r 100.0 -cye none -cyi 1 -mxd 1 -mnd 0 -vsh cube -vof 0 0 0 -vsw 360 -tsr 0.5`;
			connectDynamic -em $temp[0] $buffer[0];
			setAttr ( $temp[0] + ".turbulence" ) 5;
			parent $temp[0] $buffer[0];

			$temp = `fluidEmitter -pos -12 -46.571 8.726 -type volume -der 3.5 -her 2 -fer 4 -fdr 2 -r 100.0 -cye none -cyi 1 -mxd 1 -mnd 0 -vsh cube -vof 0 0 0 -vsw 360 -tsr 0.5`;
			connectDynamic -em $temp[0] $buffer[0];
			setAttr ( $temp[0] + ".turbulence" ) 5;
			parent $temp[0] $buffer[0];

			string $emitters[] = `listRelatives -c -typ "fluidEmitter" $buffer[0]`;

			// rename nodes

			rename $exp1 ( $groupName + "_expression" );
			rename $buffer[0] ( $groupName + "_fluid" );
			for ($current in $emitters)
			{
				rename $current ($groupName + "_" + $current);
			}

			break;

		// #################################################################################################
		// #    CREATE ICE										   						    #
		// #################################################################################################

		case "ice":
			string $buffer[], $temp[], $explression;

			// create emitter

			$temp = `emitter -pos 0 0 0 -type volume -r 10 -sro 0 -nuv 0 -cye none -cyi 1 -spd 1 -srn 0 -nsp 1 -tsp 0 -mxd 0 -mnd 0 -dx 1 -dy 0 -dz 0 -sp 0 -vsh sphere -vof 0 0 0 -vsw 360 -tsr 0.5 -afc 5 -afx 1 -arx 0 -alx 0 -rnd 0 -drs 0 -ssz 0`;
			$buffer[0] = $temp[0];

			// create trailsParticleShape

			$temp = `particle`;
			$buffer[1] = $temp[0];
			$buffer[2] = $temp[1];

			// connect trailsParticleShape to emitter

			connectDynamic -em $buffer[0] $buffer[2];

			// manage trailsParticleShape attributes

			setAttr ( $buffer[2] + ".lifespanMode" ) 1;
			setAttr ( $buffer[2] + ".lifespan" ) 5;
			setAttr ( $buffer[2] + ".particleRenderType" ) 8;
			addAttr -is true -ln "betterIllumination" -at bool -dv false $buffer[2];
			addAttr -is true -ln "surfaceShading" -at "float" -smn 0 -smx 1 -dv 0 $buffer[2];
			addAttr -is true -ln "threshold" -at "float" -smn 0 -smx 10 -dv 0 $buffer[2];
			addAttr -is true -ln "radius" -at "float" -smn 0 -smx 20 -dv 2 $buffer[2];
			addAttr -ln radiusPP -dt doubleArray $buffer[2];
			addAttr -ln radiusMultPP -dt doubleArray $buffer[2];
			addAttr -ln opacityPP -dt doubleArray $buffer[2];
			addAttr -ln colorInputBiasPP -dt doubleArray $buffer[2];
			addAttr -ln incandescenceInputBiasPP -dt doubleArray $buffer[2];
			addAttr -ln opacityInputBiasPP -dt doubleArray $buffer[2];
			addAttr -ln textureTimePP -dt doubleArray $buffer[2];
			addAttr -ln frequencyPP -dt doubleArray $buffer[2];
			addAttr -ln userVector1PP -dt vectorArray $buffer[2];
			addAttr -ln userVector2PP -dt vectorArray $buffer[2];
			addAttr -ln radiusMult -at double -smn 0 -smx 20 -dv 2.5 $buffer[2];
			addAttr -ln radiusMin -at double -smn 0 -smx 20 -dv 0.25 $buffer[2];
			addAttr -ln radiusMax -at double -smn 0 -smx 20 -dv 1.25 $buffer[2];
			addAttr -ln colorInputBiasMin -at double -smn -1 -smx 1 -dv 0 $buffer[2];
			addAttr -ln colorInputBiasMax -at double -smn -1 -smx 1 -dv 1 $buffer[2];
			addAttr -ln incandescenceInputBiasMin -at double -smn -1 -smx 1 -dv 0 $buffer[2];
			addAttr -ln incandescenceInputBiasMax -at double -smn -1 -smx 1 -dv 1 $buffer[2];
			addAttr -ln opacityInputBiasMin -at double -smn -1 -smx 1 -dv 0 $buffer[2];
			addAttr -ln opacityInputBiasMax -at double -smn -1 -smx 1 -dv 1 $buffer[2];
			addAttr -ln textureTime -at double -smn 0 -smx 20 -dv 10 $buffer[2];
			addAttr -ln frequency -at double -smn 0 -smx 3 -dv 1.5 $buffer[2];

			// create fluidShape

			$buffer[12] = `create3DFluid 20 20 20 10 10 10`;

			// MAYA 5.0 COMPATIBILITY ( THE NEXT TWO LINES ARE NOT NEEDED FOR MAYA 6+ )
			//
			$temp = `ls -sl`;
			$buffer[12] = $temp[0];

			// manage fluidShape attributes

			setAttr ( $buffer[12] + ".densityMethod" ) 3;
			setAttr ( $buffer[12] + ".densityGradient" ) 4;
			setAttr ( $buffer[12] + ".velocityMethod" ) 0;
			setAttr ( $buffer[12] + ".boundaryDraw" ) 4;
			setAttr ( $buffer[12] + ".wireframeDisplay" ) 0;
			setAttr ( $buffer[12] + ".dropoffShape" ) 2;
			setAttr ( $buffer[12] + ".edgeDropoff" ) 0;
			setAttr ( $buffer[12] + ".color[0].color_Position" ) 0.036;
			setAttr ( $buffer[12] + ".color[0].color_Color" ) 1.1685 1.420771 1.5;
			setAttr ( $buffer[12] + ".color[1].color_Position" ) 0.222;
			setAttr ( $buffer[12] + ".color[1].color_Color" ) 0.018447 0 0.286;
			setAttr ( $buffer[12] + ".colorInput" ) 4;
			setAttr ( $buffer[12] + ".incandescence[0].incandescence_Position" ) 0.164;
			setAttr ( $buffer[12] + ".incandescence[0].incandescence_Color" ) 0.1608 0.290885 0.4;
			setAttr ( $buffer[12] + ".incandescence[1].incandescence_Position" ) 1;
			setAttr ( $buffer[12] + ".incandescence[1].incandescence_Color" ) 0.0304 0.102903 0.4;
			setAttr ( $buffer[12] + ".incandescence[2].incandescence_Position" ) 0.5;
			setAttr ( $buffer[12] + ".incandescence[2].incandescence_Color" ) 0.784 0.1279 0.046256;
			removeMultiInstance -break true ( $buffer[12] + ".incandescence[2]" );
			setAttr ( $buffer[12] + ".incandescenceInput" ) 4;
			setAttr ( $buffer[12] + ".opacity[0].opacity_Position" ) 0.2;
			setAttr ( $buffer[12] + ".opacity[1].opacity_FloatValue" ) 0.58;
			setAttr ( $buffer[12] + ".opacity[1].opacity_Position" ) 0.214;
			setAttr ( $buffer[12] + ".opacity[2].opacity_FloatValue" ) 0.9;
			setAttr ( $buffer[12] + ".opacity[2].opacity_Position" ) 0.314;
			setAttr ( $buffer[12] + ".opacity[2].opacity_Interp" ) 1;
			setAttr ( $buffer[12] + ".opacity[3].opacity_FloatValue" ) 0.36;
			setAttr ( $buffer[12] + ".opacity[3].opacity_Position" ) 1;
			setAttr ( $buffer[12] + ".opacityInput" ) 4;
			setAttr ( $buffer[12] + ".quality" ) 1;
			setAttr ( $buffer[12] + ".renderInterpolator" ) 3;
			setAttr ( $buffer[12] + ".colorTexture" ) 1;
			setAttr ( $buffer[12] + ".opacityTexture" ) 1;
			setAttr ( $buffer[12] + ".textureType" ) 0;
			setAttr ( $buffer[12] + ".colorTexGain" ) 0.667;
			setAttr ( $buffer[12] + ".opacityTexGain" ) 0.588;
			setAttr ( $buffer[12] + ".amplitude" ) 1.565;
			setAttr ( $buffer[12] + ".ratio" ) 0.363;
			setAttr ( $buffer[12] + ".frequencyRatio" ) 3;
			setAttr ( $buffer[12] + ".depthMax" ) 5;
			setAttr ( $buffer[12] + ".invertTexture" ) 1;
			setAttr ( $buffer[12] + ".inflection" ) 1;
			setAttr ( $buffer[12] + ".textureScaleX" ) 4;
			setAttr ( $buffer[12] + ".textureScaleY" ) 4;
			setAttr ( $buffer[12] + ".textureScaleZ" ) 4;
			setAttr ( $buffer[12] + ".textureOriginX" ) 4.4;
			setAttr ( $buffer[12] + ".implode" ) 0.3;
			setAttr ( $buffer[12] + ".selfShadowing" ) 1;
			setAttr ( $buffer[12] + ".realLights" ) 0;
			setAttr ( $buffer[12] + ".directionalLightX" ) 0.5;
			setAttr ( $buffer[12] + ".directionalLightY" ) 2;
			setAttr ( $buffer[12] + ".directionalLightZ" ) 0.5;
			setAttr ( $buffer[12] + ".castsShadows" ) 1;
			setAttr ( $buffer[12] + ".shadowOpacity" ) 0.6;
			setAttr ( $buffer[12] + ".receiveShadows" ) 0;
			setAttr ( $buffer[12] + ".primaryVisibility" ) 0;
			setAttr ( $buffer[12] + ".visibleInReflections" ) 0;
			setAttr ( $buffer[12] + ".visibleInRefractions" ) 0;

			// assign fluidShape to trailsParticleShape

			$temp = `listConnections -s 0 -d 1 ( $buffer[12] + ".outColor" )`;
			select $buffer[2];
			sets -e -forceElement $temp[0];

			// create particleSamplerInfo

			$buffer[13] = `shadingNode -asUtility particleSamplerInfo`;

			// create arrayMapper for radiusMultPP

			$temp = `arrayMapper -target $buffer[2] -destAttr radiusMultPP -inputV ageNormalized -type ramp`;
			$buffer[3] = $temp[0];

			// create ramp for radiusMultPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[3] + ".computeNodeColor" )`;
			$buffer[4] = $temp[0];

			setAttr ( $buffer[4] + ".colorEntryList[0].color" ) 0.15 0.15 0.15;
			removeMultiInstance -break true ( $buffer[4] + ".colorEntryList[1]" );
			setAttr ( $buffer[4] + ".colorEntryList[2].color" ) 1 1 1;
			setAttr ( $buffer[4] + ".colorEntryList[2].position" ) 1;

			// create arrayMapper for opacityPP

			$temp = `arrayMapper -target $buffer[2] -destAttr opacityPP -inputV ageNormalized -type ramp`;
			$buffer[7] = $temp[0];

			// create ramp for opacityPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[7] + ".computeNodeColor" )`;
			$buffer[8] = $temp[0];

			setAttr ( $buffer[8] + ".colorEntryList[0].color" ) 0.31 0.31 0.31;
			removeMultiInstance -break true ( $buffer[8] + ".colorEntryList[1]" );
			removeMultiInstance -break true ( $buffer[8] + ".colorEntryList[2]" );

			// create connections between particleSamplerInfo and opacityPP

			connectAttr -f ( $buffer[13] + ".opacityPP" ) ( $buffer[12] + ".transparencyR" );
			connectAttr -f ( $buffer[13] + ".opacityPP" ) ( $buffer[12] + ".transparencyG" );
			connectAttr -f ( $buffer[13] + ".opacityPP" ) ( $buffer[12] + ".transparencyB" );

			// create arrayMapper for colorInputBiasPP

			$temp = `arrayMapper -target $buffer[2] -destAttr colorInputBiasPP -inputV ageNormalized -type ramp`;
			$buffer[24] = $temp[0];

			connectAttr -f ( $buffer[2] + ".colorInputBiasMin" ) ( $buffer[24] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".colorInputBiasMax" ) ( $buffer[24] + ".maxValue" );

			// create ramp for colorInputBiasPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[24] + ".computeNodeColor" )`;
			$buffer[25] = $temp[0];

			setAttr ( $buffer[25] + ".interpolation" ) 1;
			setAttr ( $buffer[25] + ".colorEntryList[0].color" ) 0.478 0.478 0.478;
			removeMultiInstance -break true ( $buffer[25] + ".colorEntryList[1]" );
			removeMultiInstance -break true ( $buffer[25] + ".colorEntryList[2]" );

			// create connections between particleSamplerInfo and colorInputBiasPP

			connectAttr -f ( $buffer[13] + ".userVector1PPX" ) ( $buffer[12] + ".colorInputBias" );

			// create arrayMapper for incandescenceInputBiasPP

			$temp = `arrayMapper -target $buffer[2] -destAttr incandescenceInputBiasPP -inputV ageNormalized -type ramp`;
			$buffer[18] = $temp[0];

			connectAttr -f ( $buffer[2] + ".incandescenceInputBiasMin" ) ( $buffer[18] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".incandescenceInputBiasMax" ) ( $buffer[18] + ".maxValue" );

			// create ramp for incandescenceInputBiasPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[18] + ".computeNodeColor" )`;
			$buffer[19] = $temp[0];

			setAttr ( $buffer[19] + ".interpolation" ) 1;
			setAttr ( $buffer[19] + ".colorEntryList[0].color" ) 0.459 0.459 0.459;
			removeMultiInstance -break true ( $buffer[19] + ".colorEntryList[1]" );
			removeMultiInstance -break true ( $buffer[19] + ".colorEntryList[2]" );

			// create connections between particleSamplerInfo and incandescenceInputBiasPP

			connectAttr -f ( $buffer[13] + ".userVector1PPY" ) ( $buffer[12] + ".incandescenceInputBias" );

			// create arrayMapper for opacityInputBiasPP

			$temp = `arrayMapper -target $buffer[2] -destAttr opacityInputBiasPP -inputV ageNormalized -type ramp`;
			$buffer[26] = $temp[0];

			connectAttr -f ( $buffer[2] + ".colorInputBiasMin" ) ( $buffer[26] + ".minValue" );
			connectAttr -f ( $buffer[2] + ".colorInputBiasMax" ) ( $buffer[26] + ".maxValue" );

			// create ramp for opacityInputBiasPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[26] + ".computeNodeColor" )`;
			$buffer[27] = $temp[0];

			setAttr ( $buffer[27] + ".interpolation" ) 1;
			setAttr ( $buffer[27] + ".colorEntryList[0].color" ) 0.348 0.348 0.348;
			removeMultiInstance -break true ( $buffer[27] + ".colorEntryList[1]" );
			removeMultiInstance -break true ( $buffer[27] + ".colorEntryList[2]" );

			// create connections between particleSamplerInfo and opacityInputBiasPP

			connectAttr -f ( $buffer[13] + ".userVector1PPZ" ) ( $buffer[12] + ".opacityInputBias" );

			// create arrayMapper for textureTimePP

			$temp = `arrayMapper -target $buffer[2] -destAttr textureTimePP -inputV ageNormalized -type ramp`;
			$buffer[20] = $temp[0];

			// create ramp for textureTimePP

			$temp = `listConnections -s 1 -d 0 ( $buffer[20] + ".computeNodeColor" )`;
			$buffer[21] = $temp[0];

			setAttr ( $buffer[21] + ".colorEntryList[0].color" ) 1 1 1;
			removeMultiInstance -break true ( $buffer[21] + ".colorEntryList[1]" );
			setAttr ( $buffer[21] + ".colorEntryList[2].color" ) 0 0 0;
			setAttr ( $buffer[21] + ".colorEntryList[2].position" ) 1;
			setAttr ( $buffer[21] + ".noise" ) 1;

			// create connections between particleSamplerInfo and textureTimePP

			connectAttr -f ( $buffer[13] + ".userVector2PPX" ) ( $buffer[12] + ".textureTime" );

			// create arrayMapper for frequencyPP

			$temp = `arrayMapper -target $buffer[2] -destAttr frequencyPP -inputV ageNormalized -type ramp`;
			$buffer[32] = $temp[0];

			// create ramp for frequencyPP

			$temp = `listConnections -s 1 -d 0 ( $buffer[32] + ".computeNodeColor" )`;
			$buffer[33] = $temp[0];

			setAttr ( $buffer[33] + ".colorEntryList[0].color" ) 1 1 1;
			removeMultiInstance -break true ( $buffer[33] + ".colorEntryList[1]" );
			setAttr ( $buffer[33] + ".colorEntryList[2].color" ) 0 0 0;
			setAttr ( $buffer[33] + ".colorEntryList[2].position" ) 1;
			setAttr ( $buffer[33] + ".noise" ) 1;

			// create connections between particleSamplerInfo and frequencyPP

			connectAttr -f ( $buffer[13] + ".userVector2PPY" ) ( $buffer[12] + ".frequency" );

			// set expressions

			$explression = "radiusPP = clamp ( radiusMin, radiusMax, radiusMult * radiusMultPP );\n";
			$explression += "userVector1PP = << -colorInputBiasPP, -incandescenceInputBiasPP, -opacityInputBiasPP >>;\n";
			$explression += "userVector2PP = << textureTimePP * textureTime, frequencyPP + frequency, 0 >>;";
			dynExpression -s $explression -c $buffer[2];

			string $groupName = `group -n "ice#" $buffer[0] $buffer[1] $buffer[12]`;
			string $tok[];
			tokenize $groupName "e" $tok;

			// rename nodes

			rename $buffer[0] ( "ice" + $tok[1] + "_emitter" );
			rename $buffer[1] ( "ice" + $tok[1] + "_particle" );
			rename $buffer[3] ( "ice" + $tok[1] + "_radMultPP_aMapper" );
			rename $buffer[4] ( "ice" + $tok[1] + "_radMultPP_ramp" );
			rename $buffer[7] ( "ice" + $tok[1] + "_opacPP_aMapper" );
			rename $buffer[8] ( "ice" + $tok[1] + "_opacPP_ramp" );
			rename $buffer[12] ( "ice" + $tok[1] + "_fluid" );
			rename $buffer[18] ( "ice" + $tok[1] + "_incanInBiasPP_aMapper" );
			rename $buffer[19] ( "ice" + $tok[1] + "_incanInBiasPP_ramp" );
			rename $buffer[20] ( "ice" + $tok[1] + "_texTimePP_aMapper" );
			rename $buffer[21] ( "ice" + $tok[1] + "_texTimePP_ramp" );
			rename $buffer[24] ( "ice" + $tok[1] + "_colorInBiasPP_aMapper" );
			rename $buffer[25] ( "ice" + $tok[1] + "_colorInBiasPP_ramp" );
			rename $buffer[26] ( "ice" + $tok[1] + "_opacInBiasPP_aMapper" );
			rename $buffer[27] ( "ice" + $tok[1] + "_opacInBiasPP_ramp" );
			rename $buffer[32] ( "ice" + $tok[1] + "_freqPP_aMapper" );
			rename $buffer[33] ( "ice" + $tok[1] + "_freqPP_ramp" );

			break;
	}

	select -cl;
}

// #################################################################################################
// #    INTERACTIVE UPDATE ( VOXEL EDITOR )							   #
// #################################################################################################

global proc interactiveUpdate_OVERBURN_PPLE ( int $flagDataType )
{
	if ( `checkBox -q -v interactiveUpdate_checkBox_OVERBURN_PPLE` == 1 )
	{
		if ( $flagDataType == 1 )
		{
			setData_OVERBURN_PPLE ( 1, 0 );
		}
		else if ( $flagDataType == 21 )
		{
			setData_OVERBURN_PPLE ( 21, 0 );
		}
		else if ( $flagDataType == 22 )
		{
			setData_OVERBURN_PPLE ( 22, 0 );
		}
		else if ( $flagDataType == 23 )
		{
			setData_OVERBURN_PPLE ( 23, 0 );
		}
		else if ( $flagDataType == 3 )
		{
			setData_OVERBURN_PPLE ( 3, 0 );
		}
		else if ( $flagDataType == 4 )
		{
			setData_OVERBURN_PPLE ( 4, 0 );
		}
		else if ( $flagDataType == 5 )
		{
			setData_OVERBURN_PPLE ( 5, 0 );
		}
		else if ( $flagDataType == 6 )
		{
			setData_OVERBURN_PPLE ( 6, 0 );
		}
	}
}

// #################################################################################################
// #    CREATE VOXEL HANDLES ( VOXEL EDITOR )							   #
// #################################################################################################

global proc createVoxelHandles_OVERBURN_PPLE ()
{
	string $sel[] = `ls -sl`;
	string $transform, $grpCV[], $voxelHandle;
	float $dim[], $pos[];

	if ( size ( $sel ) != 0 )
	{
		if ( `nodeType $sel[0]` == "transform" )
		{
			$transform = $sel[0];
			$sel = `listRelatives -pa -s $sel[0]`;
		}

		if ( size ( $sel ) != 0 )
		{
			if ( `nodeType $sel[0]` != "fluidShape" )
			{
				$sel[0] = "";
			}
		}

		if ( $sel[0] != "" )
		{
			textField -e -tx $sel[0] fluidContainer_textField_OVERBURN_PPLE;

			$grpCV = `ls -o "*.grpVoxelHandles_OVERBURN_PPLE"`;

			if ( size ( $grpCV ) != 0 )
			{
				delete $grpCV;
			}

			$grpCV[0] = `createNode transform -n grpCV`;
			addAttr -sn grpVoxelHandles_OVERBURN_PPLE -at byte -h 1 $grpCV[0];
			pointConstraint $transform $grpCV[0];
			orientConstraint $transform $grpCV[0];
			scaleConstraint $transform $grpCV[0];
			setAttr -k 0 -l 1 ( $grpCV[0] + ".t" );
			setAttr -k 0 -l 1 ( $grpCV[0] + ".r" );
			setAttr -k 0 -l 1 ( $grpCV[0] + ".s" );

			$dim = `getAttr ( $sel[0] + ".resolution" )`;

			for ( $i = 0; $i < $dim[0]; $i++ )
			{
				for ( $j = 0; $j < $dim[1]; $j++ )
				{
					for ( $k = 0; $k < $dim[2]; $k++ )
					{
						$pos = `fluidVoxelInfo -vc -xi $i -yi $j -zi $k $sel[0]`;
						$voxelHandle = `createNode transform -n ( "voxel_" + $i + "_" + $j + "_" + $k )`;
						addAttr -sn voxelHandle_OVERBURN_PPLE -at byte -h 1 $voxelHandle;
						move -r $pos[0] $pos[1] $pos[2] $voxelHandle;
						parent $voxelHandle $grpCV[0];
						setAttr -k 0 -l 1 ( $voxelHandle + ".t" );
						setAttr -k 0 -l 1 ( $voxelHandle + ".r" );
						setAttr -k 0 -l 1 ( $voxelHandle + ".s" );
						setAttr -k 0 -l 1 ( $voxelHandle + ".v" );
						setAttr ( $voxelHandle + ".displayHandle" ) 1;
					}
				}
			}

			select $transform;
		}
	}
}

// #################################################################################################
// #    SET VOXEL DATA ( VOXEL EDITOR )								   #
// #################################################################################################

global proc setData_OVERBURN_PPLE ( int $flagDataType, int $flagUseTexture )
{
	string $fluidContainer = `textField -q -tx fluidContainer_textField_OVERBURN_PPLE`;

	if ( `objExists $fluidContainer` == 0 )
	{
		error "The \"Fluid Container\" field is empty, or points to a non existing fluidContainer.";
	}
	else
	{
		string $sel[] = `ls -sl`;
		int $count = size ( $sel );

		string $texture, $tokens[];
		float $blend, $density, $velocityX, $velocityY, $velocityZ, $temperature, $fuel, $color[], $falloff;
		int $flagTexture;

		if ( $flagUseTexture == 1 )
		{
			$texture = `textField -q -tx texture_textField_OVERBURN_PPLE`;
			$flagTexture = 1;
		}

		if ( `objExists $texture` == 0 )
		{
			$flagTexture = 0;
			$blend = `radioButtonGrp -q -sl blend_radioButtonGrp_OVERBURN_PPLE`;
			$density = `floatSliderGrp -q -v density_floatSliderGrp_OVERBURN_PPLE`;
			$velocityX = `floatField -q -v velocityX_floatField_OVERBURN_PPLE`;
			$velocityY = `floatField -q -v velocityY_floatField_OVERBURN_PPLE`;
			$velocityZ = `floatField -q -v velocityZ_floatField_OVERBURN_PPLE`;
			$temperature = `floatSliderGrp -q -v temperature_floatSliderGrp_OVERBURN_PPLE`;
			$fuel = `floatSliderGrp -q -v fuel_floatSliderGrp_OVERBURN_PPLE`;
			$color = `colorSliderGrp -q -rgb color_colorSliderGrp_OVERBURN_PPLE`;
			$falloff = `floatSliderGrp -q -v falloff_floatSliderGrp_OVERBURN_PPLE`;
		}

		for ( $i = 0; $i < $count; $i++ )
		{
			if ( `objExists ( $sel[$i] + "*.voxelHandle_OVERBURN_PPLE" )` == 1 )
			{
				tokenize $sel[$i] "_" $tokens;

				if ( $flagTexture == 1 )
				{
					setAttr ( $texture + ".rpc" ) ( ( int ) $tokens[1] ) ( ( int ) $tokens[2] )( ( int ) $tokens[3] );
				}

				if ( $flagDataType == 1 )
				{
					if ( $flagTexture == 1 )
					{
						$density = `getAttr ( $texture + ".outAlpha" )`;
					}

					if ( $blend == 1 )
					{
						setFluidAttr -at density -fv $density -xi ( ( int ) $tokens[1] ) -yi ( ( int ) $tokens[2] ) -zi ( ( int ) $tokens[3] ) $fluidContainer;
					}
					else if ( $blend == 2 )
					{
						setFluidAttr -ad -at density -fv $density -xi ( ( int ) $tokens[1] ) -yi ( ( int ) $tokens[2] ) -zi ( ( int ) $tokens[3] ) $fluidContainer;
					}
					else
					{
						setFluidAttr -at density -fv ( -$density ) -xi ( ( int ) $tokens[1] ) -yi ( ( int ) $tokens[2] ) -zi ( ( int ) $tokens[3] ) $fluidContainer;
					}

				}
				else if ( $flagDataType == 21 )
				{
					if ( $flagTexture == 1 )
					{
						$velocityX = `getAttr ( $texture + ".outAlpha" )`;
					}

					if ( $blend == 1 )
					{
						setFluidAttr -at velocity -fv $velocityX -x -xi ( ( int ) $tokens[1] ) -yi ( ( int ) $tokens[2] ) -zi ( ( int ) $tokens[3] ) $fluidContainer;
					}
					else if ( $blend == 2 )
					{
						setFluidAttr -ad -at velocity -fv $velocityX -x -xi ( ( int ) $tokens[1] ) -yi ( ( int ) $tokens[2] ) -zi ( ( int ) $tokens[3] ) $fluidContainer;
					}
					else
					{
						setFluidAttr -ad -at velocity -fv ( -$velocityX ) -x -xi ( ( int ) $tokens[1] ) -yi ( ( int ) $tokens[2] ) -zi ( ( int ) $tokens[3] ) $fluidContainer;
					}
				}
				else if ( $flagDataType == 22 )
				{
					if ( $flagTexture == 1 )
					{
						$velocityY = `getAttr ( $texture + ".outAlpha" )`;
					}

					if ( $blend == 1 )
					{
						setFluidAttr -at velocity -fv $velocityY -y -xi ( ( int ) $tokens[1] ) -yi ( ( int ) $tokens[2] ) -zi ( ( int ) $tokens[3] ) $fluidContainer;
					}
					else if ( $blend == 2 )
					{
						setFluidAttr -ad -at velocity -fv $velocityY -y -xi ( ( int ) $tokens[1] ) -yi ( ( int ) $tokens[2] ) -zi ( ( int ) $tokens[3] ) $fluidContainer;
					}
					else
					{
						setFluidAttr -ad -at velocity -fv ( -$velocityY ) -y -xi ( ( int ) $tokens[1] ) -yi ( ( int ) $tokens[2] ) -zi ( ( int ) $tokens[3] ) $fluidContainer;
					}
				}
				else if ( $flagDataType == 23 )
				{
					if ( $flagTexture == 1 )
					{
						$velocityZ = `getAttr ( $texture + ".outAlpha" )`;
					}

					if ( $blend == 1 )
					{
						setFluidAttr -at velocity -fv $velocityZ -z -xi ( ( int ) $tokens[1] ) -yi ( ( int ) $tokens[2] ) -zi ( ( int ) $tokens[3] ) $fluidContainer;
					}
					else if ( $blend == 2 )
					{
						setFluidAttr -ad -at velocity -fv $velocityZ -z -xi ( ( int ) $tokens[1] ) -yi ( ( int ) $tokens[2] ) -zi ( ( int ) $tokens[3] ) $fluidContainer;
					}
					else
					{
						setFluidAttr -ad -at velocity -fv ( -$velocityZ ) -z -xi ( ( int ) $tokens[1] ) -yi ( ( int ) $tokens[2] ) -zi ( ( int ) $tokens[3] ) $fluidContainer;
					}
				}
				else if ( $flagDataType == 3 )
				{
					if ( $flagTexture == 1 )
					{
						$temperature = `getAttr ( $texture + ".outAlpha" )`;
					}

					if ( $blend == 1 )
					{
						setFluidAttr -at temperature -fv $temperature -yi ( ( int ) $tokens[2] ) -zi ( ( int ) $tokens[3] ) $fluidContainer;
					}
					else if ( $blend == 2 )
					{
						setFluidAttr -ad -at temperature -fv $temperature -yi ( ( int ) $tokens[2] ) -zi ( ( int ) $tokens[3] ) $fluidContainer;
					}
					else
					{
						setFluidAttr -ad -at temperature -fv ( -$temperature ) -yi ( ( int ) $tokens[2] ) -zi ( ( int ) $tokens[3] ) $fluidContainer;
					}
				}
				else if ( $flagDataType == 4 )
				{
					if ( $flagTexture == 1 )
					{
						$fuel = `getAttr ( $texture + ".outAlpha" )`;
					}

					if ( $blend == 1 )
					{
						setFluidAttr -at fuel -fv $fuel -yi ( ( int ) $tokens[2] ) -zi ( ( int ) $tokens[3] ) $fluidContainer;
					}
					else if ( $blend == 2 )
					{
						setFluidAttr -ad -at fuel -fv $fuel -yi ( ( int ) $tokens[2] ) -zi ( ( int ) $tokens[3] ) $fluidContainer;
					}
					else
					{
						setFluidAttr -ad -at fuel -fv ( -$fuel ) -yi ( ( int ) $tokens[2] ) -zi ( ( int ) $tokens[3] ) $fluidContainer;
					}
				}
				else if ( $flagDataType == 5 )
				{
					if ( $flagTexture == 1 )
					{
						$color = `getAttr ( $texture + ".outColor" )`;
					}

					if ( $blend == 1 )
					{
						setFluidAttr -at color -vv $color[0] $color[1] $color[2] -xi ( ( int ) $tokens[1] ) -yi ( ( int ) $tokens[2] ) -zi ( ( int ) $tokens[3] ) $fluidContainer;
					}
					else if ( $blend == 2 )
					{
						setFluidAttr -ad -at color -vv $color[0] $color[1] $color[2] -xi ( ( int ) $tokens[1] ) -yi ( ( int ) $tokens[2] ) -zi ( ( int ) $tokens[3] ) $fluidContainer;
					}
					else
					{
						setFluidAttr -ad -at color -vv ( -$color[0] ) ( -$color[1] ) ( -$color[2] ) -xi ( ( int ) $tokens[1] ) -yi ( ( int ) $tokens[2] ) -zi ( ( int ) $tokens[3] ) $fluidContainer;
					}
				}
				else if ( $flagDataType == 6 )
				{
					if ( $flagTexture == 1 )
					{
						$falloff = `getAttr ( $texture + ".outAlpha" )`;
					}

					if ( $blend == 1 )
					{
						setFluidAttr -at falloff -fv $falloff -yi ( ( int ) $tokens[2] ) -zi ( ( int ) $tokens[3] ) $fluidContainer;
					}
					else if ( $blend == 2 )
					{
						setFluidAttr -ad -at falloff -fv $falloff -yi ( ( int ) $tokens[2] ) -zi ( ( int ) $tokens[3] ) $fluidContainer;
					}
					else
					{
						setFluidAttr -ad -at falloff -fv ( -$falloff ) -yi ( ( int ) $tokens[2] ) -zi ( ( int ) $tokens[3] ) $fluidContainer;
					}
				}
			}
		}

		int $uiSettings[];

		if ( ( float ) `about -v` < 7.0 )
		{
			$uiSettings = { 1, 1, 1, 1, 1, 1 };
		}
		else
		{
			$uiSettings = { 1, 1, 1, 1, 1, 1, 1 };
		}
	}
}

// #################################################################################################
// #    UPDATE UI ELEMENTS ( VOXEL EDITOR )							   #
// #################################################################################################

global proc updateUI_OVERBURN_PPLE ( int $flag )
{
	string $fluidContainer = `textField -q -tx fluidContainer_textField_OVERBURN_PPLE`;

	if ( `objExists $fluidContainer` == 1 )
	{
		string $sel[] = `ls -sl`;
		int $count = size ( $sel );

		for ( $i = 0; $i < $count; $i++ )
		{
			if ( `objExists ( $sel[$i] + "*.voxelHandle_OVERBURN_PPLE" )` == 1 )
			{
				string $tokens[];
				float $buffer[];
				tokenize $sel[$i] "_" $tokens;

				if ( $flag == 1 )
				{	// density
					$buffer = `getFluidAttr -at density -xi ( ( int ) $tokens[1] ) -yi ( ( int ) $tokens[2] ) -zi ( ( int ) $tokens[3] ) $fluidContainer`;
					floatSliderGrp -e -v $buffer[0] density_floatSliderGrp_OVERBURN_PPLE;
				}
				else if ( $flag == 21 )
				{
					// velocityX
					$buffer = `getFluidAttr -at velocity -xi ( ( int ) $tokens[1] ) -yi ( ( int ) $tokens[2] ) -zi ( ( int ) $tokens[3] ) $fluidContainer`;
					floatField -e -v $buffer[0] velocityX_floatField_OVERBURN_PPLE;
				}
				else if ( $flag == 22 )
				{
					// velocityY
					$buffer = `getFluidAttr -at velocity -xi ( ( int ) $tokens[1] ) -yi ( ( int ) $tokens[2] ) -zi ( ( int ) $tokens[3] ) $fluidContainer`;
					floatField -e -v $buffer[1] velocityY_floatField_OVERBURN_PPLE;
				}
				else if ( $flag == 23 )
				{
					// velocityZ
					$buffer = `getFluidAttr -at velocity -xi ( ( int ) $tokens[1] ) -yi ( ( int ) $tokens[2] ) -zi ( ( int ) $tokens[3] ) $fluidContainer`;
					floatField -e -v $buffer[2] velocityZ_floatField_OVERBURN_PPLE;
				}
				else if ( $flag == 3 )
				{
					// temperature
					$buffer = `getFluidAttr -at temperature -xi ( ( int ) $tokens[1] ) -yi ( ( int ) $tokens[2] ) -zi ( ( int ) $tokens[3] ) $fluidContainer`;
					floatSliderGrp -e -v $buffer[0] temperature_floatSliderGrp_OVERBURN_PPLE;
				}
				else if ( $flag == 4 )
				{
					// fuel
					$buffer = `getFluidAttr -at fuel -xi ( ( int ) $tokens[1] ) -yi ( ( int ) $tokens[2] ) -zi ( ( int ) $tokens[3] ) $fluidContainer`;
					floatSliderGrp -e -v $buffer[0] fuel_floatSliderGrp_OVERBURN_PPLE;
				}
				else if ( $flag == 5 )
				{
					// color
					$buffer = `getFluidAttr -at color -xi ( ( int ) $tokens[1] ) -yi ( ( int ) $tokens[2] ) -zi ( ( int ) $tokens[3] ) $fluidContainer`;
					colorSliderGrp -e -rgb $buffer[0] $buffer[1] $buffer[2] color_colorSliderGrp_OVERBURN_PPLE;
				}
				else if ( $flag == 6 )
				{
					// falloff
					$buffer = `getFluidAttr -at falloff -xi ( ( int ) $tokens[1] ) -yi ( ( int ) $tokens[2] ) -zi ( ( int ) $tokens[3] ) $fluidContainer`;
					floatSliderGrp -e -v $buffer[0] falloff_floatSliderGrp_OVERBURN_PPLE;
				}

				break;
			}
		}
	}
}

// #################################################################################################
// #    GET 3D TEXTURE ( VOXEL EDITOR )								   #
// #################################################################################################

global proc getTexture_OVERBURN_PPLE ()
{
	string $sel[] = `ls -sl`;

	if ( size ( $sel ) != 0 )
	{
		textField -e -tx $sel[0] texture_textField_OVERBURN_PPLE;
	}
}